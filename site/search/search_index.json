{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udf1f The Software Way Knowledge Portal \ud83d\ude80","text":"<p>Welcome to The Software Way,  way for mastering software engineering concepts, coding practice, and technical resources.  </p>"},{"location":"#quick-access","title":"\ud83d\udcda Quick Access","text":"<ul> <li> <p>Operating Systems (OS) \u2014 Scheduling, Memory, Deadlocks   \ud83d\udc49 Explore OS </p> </li> <li> <p>Database Management Systems (DBMS) \u2014 ER Model, Normalization, Transactions   \ud83d\udc49 Explore DBMS </p> </li> <li> <p>Object-Oriented Programming (OOPs) \u2014 Principles, Design Patterns, Examples   \ud83d\udc49 Explore OOPs </p> </li> </ul>"},{"location":"#connect-with-me","title":"\ud83d\udd17 Connect with Me","text":"<p>\ud83d\udc8c Email: abhinavppradeep2@gmail.com \ud83d\udcbc LinkedIn: linkedin.com/in/abhinavppradeep \ud83d\udcbb GitHub: github.com/abhinavppradeep \ud83c\udf10 Website: abhinavppradeep.me </p> <p>\u2728 \u201cCode. Learn. Build. Repeat.\u201d </p>"},{"location":"tags/","title":"Browse by tag","text":"<p>Use tags to jump across sections. Each page declares tags in its front\u2011matter.</p>","tags":["index"]},{"location":"dbms/","title":"Database Fundamentals","text":"<p>Author: Abhinav P Pradeep </p>"},{"location":"dbms/#sql-commands","title":"SQL Commands","text":""},{"location":"dbms/#data-definition-language-ddl","title":"Data Definition Language (DDL)","text":"<p>DDL is used to define or change the structure/schema of database objects like tables, views, and indexes. DDL commands are auto-committed, meaning changes cannot be rolled back.</p> Command Description CREATE Creates new table, view, index, etc. DROP Deletes table or database permanently ALTER Modifies structure (e.g., add/remove column) TRUNCATE Deletes all rows without logging individual deletions RENAME Renames a table or column <p>Note: DDL commands are auto-committed. Changes cannot be rolled back.</p>"},{"location":"dbms/#data-manipulation-language-dml","title":"Data Manipulation Language (DML)","text":"<p>DML is used to manipulate or query data inside existing tables. DML operations can be rolled back until explicitly committed.</p> Command Description SELECT Retrieves data INSERT Adds new row(s) UPDATE Modifies existing row(s) DELETE Removes specific row(s)"},{"location":"dbms/#transaction-control-language-tcl","title":"Transaction Control Language (TCL)","text":"<p>TCL is used to manage transactions in a database and control their execution.</p> Command Description COMMIT Saves all changes made during the transaction ROLLBACK Undoes all changes made during the transaction SAVEPOINT Creates a point to which you can roll back SET TRANSACTION Sets properties like isolation level <p>Note: TCL is used with DML, not DDL.</p>"},{"location":"dbms/#summary-of-sql-commands","title":"Summary of SQL Commands","text":"Feature DDL DML TCL Changes Schema? \u2705 Yes \u274c No \u274c No Changes Data? \u274c No \u2705 Yes \u2699 Controls DML Auto-Commit? \u2705 Yes \u274c No \u274c No Rollback? \u274c No \u2705 Yes \u2705 Yes <p>Example Workflow:</p> <pre><code>BEGIN;\nINSERT INTO employee VALUES (101, 'Abhinav', 'HR');\nSAVEPOINT sp1;\nUPDATE employee SET dept = 'Tech' WHERE id = 101;\nROLLBACK TO sp1;\nCOMMIT;\n</code></pre>"},{"location":"dbms/#database-architectures","title":"Database Architectures","text":""},{"location":"dbms/#2-tier-vs-3-tier-architecture","title":"2-Tier vs. 3-Tier Architecture","text":""},{"location":"dbms/#what-is-a-tier","title":"What is a Tier?","text":"<p>A \"tier\" refers to a layer in the architecture of a database system: - 2-tier = 2 layers - 3-tier = 3 layers</p> <p>These architectures define how clients interact with databases.</p>"},{"location":"dbms/#two-tier-architecture-client-server","title":"Two-Tier Architecture (Client-Server)","text":"<p>Structure:</p> <pre><code>Client (UI + Application) &lt;---- JDBC/ODBC ----&gt; Database Server\n</code></pre> <p>Layers:</p> Layer Description Client (Tier 1) Runs UI and Application Logic (API) DB Server (Tier 2) Stores and processes data <p>How It Works: 1. Client has an interface (e.g., Java App). 2. Interface uses JDBC/ODBC to connect to the server. 3. Sends SQL queries. 4. Server processes queries and returns results.</p> <p>Real-life Examples: - IRCTC reservation at railway station (ticket clerk system). - Visiting a bank physically and doing credit/debit from a teller system.</p> <p>Advantages: - Simple architecture. - Easy to maintain (few clients, secured environment).</p> <p>Disadvantages:</p> Issue Why? Scalability Can't handle many users at once Security Client directly interacts with DB \u2013 risky"},{"location":"dbms/#three-tier-architecture","title":"Three-Tier Architecture","text":"<p>Structure:</p> <pre><code>Client (UI) &lt;--&gt; Business Layer (Application Server) &lt;--&gt; Database\n</code></pre> <p>Layers:</p> Tier Description Tier 1 \u2013 Client UI: Users interact via app/browser Tier 2 \u2013 Business Layer Processes logic, prepares queries Tier 3 \u2013 Database Server Stores, retrieves data <p>How It Works: 1. Client uses UI (interface) \u2013 fills form, selects data. 2. Request is sent to the Business Layer. 3. Business Layer:    - Validates data.    - Converts requests into DB queries.    - Sends to DB server. 4. DB sends result \u2192 Business Layer \u2192 User.</p> <p>Real-life Examples: - IRCTC website/app ticket booking. - Net banking / UPI apps. - Gmail, YouTube \u2013 All use 3-tier model.</p> <p>Advantages:</p> Feature Benefit Scalability Millions of users can access easily Security Users never touch DB directly Modular UI, logic, and data are separate <p>Disadvantages: - Maintenance is harder (more layers = more complexity).</p> <p>Comparison Table: 2-Tier vs. 3-Tier:</p> Feature 2-Tier 3-Tier Layers Client + DB Client + Business + DB Security \u274c Direct DB access \u2705 No direct DB access Scalability \u274c Limited users \u2705 Massive users Maintenance \u2705 Simple \u274c Complex Used In Bank counters, railway office IRCTC website, Net banking <p>Real-world Analogies:</p> <p>Bank: - 2-Tier: You visit branch \u2192 Clerk uses machine \u2192 Direct DB. - 3-Tier: You use net banking app \u2192 App processes \u2192 Queries DB.</p> <p>Railways: - 2-Tier: Station ticket counter. - 3-Tier: Booking via IRCTC app.</p> <p>Quick Recap: - 2-Tier = Client + DB (Simple but insecure). - 3-Tier = Client + App Server + DB (Secure, Scalable). - Real-use of 3-Tier: All modern web apps. - Why move to 3-Tier? Security &amp; Scalability.</p>"},{"location":"dbms/#database-schema","title":"Database Schema","text":""},{"location":"dbms/#what-is-a-schema","title":"What is a Schema?","text":"<p>A schema is a logical structure or blueprint of the database. It defines how data is organized and how relationships between data are handled.</p> <p>Simple Definition: - A schema is a logical representation of the database (not physical). - It\u2019s how DBMS shows the data to users, usually in the form of tables or entities.</p> <p>Schema vs. Physical Storage:</p> Aspect Schema (Logical) Physical Data Format Tables / ER Model Files / Binary Stored in Memory (representation) Hard disk / backend Used for Data design, query Data storage, efficiency <p>Schema Example (Student Entity):</p> Attribute Data Type Roll Number Integer Name Varchar Address Varchar <p>This is the logical structure (schema) of the Student table.</p> <p>Schema in SQL (Implementation): We use SQL DDL commands to implement a schema.</p> <pre><code>CREATE TABLE Student (\n  RollNo INT,\n  Name VARCHAR(50),\n  Address VARCHAR(100)\n);\n</code></pre> SQL Component Purpose CREATE TABLE Creates schema (table) ALTER TABLE Modifies schema DROP TABLE Deletes schema <p>Real-World Analogy: - Think of a schema like a blueprint of a house (design of rooms, layout). - Actual data is like furniture and people inside it.</p> <p>Schema and ER Models: - In ER Model:   - Entities like Student, Course are represented.   - Each has attributes (e.g., name, roll no).   - This becomes your schema. - Schema can be for:   - A single table.   - Or a set of related tables (e.g., University database).</p>"},{"location":"dbms/#three-schema-architecture","title":"Three-Schema Architecture","text":"<p>Purpose: - The main goal is data abstraction and data independence. - Users should not worry about:   - How or where the data is stored physically.   - Format or structure of data files.   - Changes in database internals. - Users interact with a logical view, not the actual data files.</p> <p>The Three Levels of Abstraction:</p>"},{"location":"dbms/#external-schema-view-level","title":"External Schema (View Level)","text":"<ul> <li>Defines how users see the data.</li> <li>Key Points:</li> <li>Different users \u2192 different views.</li> <li>Each view shows only relevant data.</li> <li>Provides security &amp; customization.</li> <li>Example:</li> <li>Student sees: Marks, Attendance, Fee status.</li> <li>Faculty sees: Enter marks, Student list, Apply leave.</li> <li>Dean/Admin sees: All students, faculty records, salary info.</li> <li>This is what you see on websites like Flipkart, Gmail, Paytm \u2014 the UI view after logging in.</li> </ul>"},{"location":"dbms/#conceptual-schema-logical-level","title":"Conceptual Schema (Logical Level)","text":"<ul> <li>Describes what data is stored and relationships among data.</li> <li>Key Elements:</li> <li>Tables (e.g., Student, Course, Faculty, Book).</li> <li>Columns (e.g., Roll No, Name, Age).</li> <li>Relationships (e.g., Student \u27f7 Course).</li> <li>Constraints (e.g., Roll No is Primary Key).</li> <li>Think of this as the blueprint or ER diagram of your database.</li> <li>Used by: Database Designers.</li> <li>They define the structure but do not store actual data.</li> </ul>"},{"location":"dbms/#internal-schema-physical-level","title":"Internal Schema (Physical Level)","text":"<ul> <li>Describes how data is stored physically on storage devices.</li> <li>Includes:</li> <li>File structures.</li> <li>Indexing.</li> <li>Compression.</li> <li>Partitioning (Centralized or Distributed storage).</li> <li>Data fragmentation.</li> <li>Examples:</li> <li>Data is stored in files (not tables).</li> <li>Format: Binary, Flat files, CSV, etc.</li> <li>This level is managed by the Database Administrator (DBA).</li> </ul> <p>Analogy: Building a House:</p> Role Schema Level Description End User External Sees the house\u2019s rooms and layout Architect Conceptual Creates the blueprint (room size, type, layout) Contractor/Builder Internal Builds the house using bricks, cement, wiring <p>Visual Diagram:</p> <pre><code>          +----------------------+\n          |     External View    |\n          |  (Multiple user views)|\n          +----------\u25b2-----------+\n                     |\n          +----------\u25bc-----------+\n          |   Conceptual Schema  |\n          |  (Tables &amp; Relations)|\n          +----------\u25b2-----------+\n                     |\n          +----------\u25bc-----------+\n          |     Internal Schema  |\n          | (Files, Indexes, HDD)|\n          +----------------------+\n</code></pre>"},{"location":"dbms/#data-independence","title":"Data Independence","text":"<p>Definition: - The ability to change the schema at one level of the database system without changing the schema at the next higher level. - Goal:   - Users can access data anytime, anywhere, without worrying about:     - How data is stored (backend).     - What tables or structure are involved.     - What indexes or file structures are used.</p> <p>Why Data Independence Exists? - Based on the 3-Schema Architecture:   - View Level: What the user sees (limited or full access \u2014 like app interface).   - Conceptual Level: Logical design (tables, columns, relationships, constraints like PK, FK).   - Physical Level: Actual storage (file structures, indexes, data structures like heap, B+ tree).</p> <p>Types of Data Independence:</p>"},{"location":"dbms/#logical-data-independence","title":"Logical Data Independence","text":"<ul> <li>Changes at: Conceptual Level.</li> <li>No effect on: View Level.</li> <li>Meaning:</li> <li>User applications don\u2019t break even if:<ul> <li>New columns are added.</li> <li>Existing columns are removed.</li> <li>Tables are modified.</li> </ul> </li> <li>Example:</li> <li>User 1 adds a \u201cMobile Number\u201d column to Student table.</li> <li>User 2 still sees only \"Name\" and \"Age\".</li> <li>App continues to work smoothly.</li> <li>Achieved Using:</li> <li>Views (Virtual Tables).</li> </ul> <pre><code>CREATE VIEW student_view AS\nSELECT name, age FROM Student;\n</code></pre>"},{"location":"dbms/#physical-data-independence","title":"Physical Data Independence","text":"<ul> <li>Changes at: Physical Level.</li> <li>No effect on: Conceptual Level.</li> <li>Meaning:</li> <li>Back-end storage operations don't affect the logical schema.</li> <li>Example:</li> <li>Moving database from Hard Disk 1 \u2192 Hard Disk 2.</li> <li>Changing data structure from Sequential Access \u2192 Linked Access.</li> <li>Adding indexes or optimizing files.</li> <li>Used For:</li> <li>Faster data access.</li> <li>Efficient storage changes without user noticing.</li> </ul> <p>Key Concept: Transparency: - Users feel like data is right with them, always available and fast. - In reality, DBMS handles all changes behind the scenes. - Real-World Example:   - Gmail, UMS portals, shopping apps.   - They update and optimize daily (add columns, move storage).   - You never notice it!</p>"},{"location":"dbms/#integrity-constraints","title":"Integrity Constraints","text":""},{"location":"dbms/#what-are-integrity-constraints","title":"What Are Integrity Constraints?","text":"<p>Definition: - Integrity constraints are rules applied on database columns (attributes) to ensure valid, accurate, and consistent data is stored. - They restrict invalid data from being entered into the database. - Think of them as data quality rules applied while inserting, updating, or deleting records.</p> <p>Why Do We Need Constraints?: - Without constraints:   - Any type of data can be inserted (e.g., age = -10, phone = \"abc\").   - Data becomes unreliable or inconsistent.   - Relationships between tables may break (e.g., orphan rows). - Constraints enforce:   - Correctness.   - Reliability.   - Uniqueness.   - Consistency.</p>"},{"location":"dbms/#types-of-integrity-constraints","title":"Types of Integrity Constraints","text":""},{"location":"dbms/#domain-constraints","title":"Domain Constraints","text":"<ul> <li>Define the valid set of values for an attribute (column).</li> <li>Applied via Data Type and Check Conditions.</li> <li>Example:</li> </ul> <pre><code>age INT CHECK (age &gt; 0);\nphone_number CHAR(10);\n</code></pre> <ul> <li>Prevents:</li> <li>Negative marks or age.</li> <li>Invalid phone number lengths.</li> <li>Wrong data types.</li> </ul>"},{"location":"dbms/#entity-integrity-constraint","title":"Entity Integrity Constraint","text":"<ul> <li>Ensures that each record is uniquely identifiable.</li> <li>Implemented using Primary Key.</li> <li>Rule:</li> <li>Primary Key must be Unique and Not Null.</li> </ul> <pre><code>PRIMARY KEY (student_id)\n</code></pre> <ul> <li>Each entity (like Student, Employee) should have at least one unique identifier.</li> </ul>"},{"location":"dbms/#referential-integrity-constraint","title":"Referential Integrity Constraint","text":"<ul> <li>Ensures relationship consistency between two tables.</li> <li>Enforced using Foreign Key.</li> <li>Rule:</li> <li>If a row in Child Table refers to a Parent Table, that value must exist in the parent.</li> </ul> <pre><code>FOREIGN KEY (course_id) REFERENCES Courses(course_id)\n</code></pre> <ul> <li>Prevents:</li> <li>Orphan records.</li> <li>Inserting child rows without a valid parent.</li> </ul>"},{"location":"dbms/#unique-constraint","title":"Unique Constraint","text":"<ul> <li>Ensures that a column (or set of columns) has only unique values.</li> <li>Example:</li> </ul> <pre><code>email VARCHAR(100) UNIQUE\n</code></pre> <ul> <li>Candidate keys are attributes with unique constraints.</li> <li>You can have multiple UNIQUE constraints, but only one PRIMARY KEY.</li> </ul>"},{"location":"dbms/#not-null-constraint","title":"Not Null Constraint","text":"<ul> <li>Ensures that a column cannot have NULL value.</li> <li>Example:</li> </ul> <pre><code>name VARCHAR(50) NOT NULL\n</code></pre> <ul> <li>Required when a field is mandatory (e.g., user\u2019s name, email).</li> </ul> <p>Summary Table:</p> Constraint Type Purpose Implementation Example Domain Valid data type or value range Data Type + CHECK age INT CHECK(age &gt; 0) Entity Integrity Uniquely identify rows PRIMARY KEY PRIMARY KEY(student_id) Referential Integrity Maintain parent-child table consistency FOREIGN KEY FOREIGN KEY(course_id) REFERENCES ... Unique Enforce uniqueness on column(s) UNIQUE email VARCHAR(100) UNIQUE Not Null Ensure value must be provided NOT NULL name VARCHAR(50) NOT NULL <p>Mnemonic for Constraints: - DUFUN-R:   - Domain   - Unique   - Foreign Key (Referential)   - Update Integrity (via PK)   - Not Null   - Real-world Consistency</p> <p>Common SQL Example:</p> <pre><code>CREATE TABLE Student (\n    student_id INT PRIMARY KEY,\n    name VARCHAR(50) NOT NULL,\n    email VARCHAR(100) UNIQUE,\n    age INT CHECK (age &gt; 0),\n    dept_id INT,\n    FOREIGN KEY (dept_id) REFERENCES Department(dept_id)\n);\n</code></pre> <p>Interview Tip: - \u201cIntegrity constraints ensure your database remains clean, consistent, and relationally accurate. Without them, data becomes garbage!\u201d - Be ready to explain each constraint with one example.</p>"},{"location":"dbms/#keys-in-dbms","title":"Keys in DBMS","text":""},{"location":"dbms/#what-is-a-key","title":"What is a Key?","text":"<ul> <li>A key is an attribute (or a set of attributes) used to uniquely identify tuples (rows) in a relation (table).</li> <li>This helps avoid duplication and confusion between identical-looking rows.</li> </ul> <p>Real-life Analogy: - Think of keys like your Aadhaar, Roll No, or Email \u2013 they make sure you\u2019re you, even if someone has your same name and age.</p> <p>Example: Student Table:</p> Name City Age Roll No Aadhaar No Email ID Reddy Delhi 21 01 XX123... reddy01@email.com Reddy Delhi 21 03 YY456... reddy03@email.com <ul> <li>Both have the same name, city, and age \u2013 but Roll No, Aadhaar, Email are different!</li> <li>These unique fields help identify them uniquely.</li> </ul>"},{"location":"dbms/#candidate-key","title":"Candidate Key","text":"<p>Definition: - A Candidate Key is a minimal super key \u2013 a field (or combination of fields) that can uniquely identify every row in the table. - Each candidate key is a strong contender to become the primary key.</p> <p>Properties: - Must be unique across rows. - Must be minimal (no unnecessary extra attributes). - A table can have multiple candidate keys.</p> <p>Examples (from Student Table): - Possible Candidate Keys:   - Roll Number   - Aadhaar Number   - Voter ID   - License Number   - Email ID   - Phone Number - All the above are:   - Unique   - Non-repeating   - Sufficient to identify each student</p>"},{"location":"dbms/#primary-key","title":"Primary Key","text":"<ul> <li>A Primary Key is one selected candidate key that we use to uniquely identify each row in practice.</li> <li>Chosen from the candidate key set.</li> <li>Only one Primary Key per table.</li> <li>Cannot be NULL.</li> <li>Choose the most practical and consistent one, like Roll No or Aadhaar.</li> </ul>"},{"location":"dbms/#alternative-keys","title":"Alternative Keys","text":"<ul> <li>The remaining candidate keys, after choosing the primary key, are called Alternative Keys.</li> <li>They are still unique and valid \u2013 just not selected as the main identifier.</li> </ul> <p>Tips for Interviews &amp; Exams: - \u201cPrimary key is always a candidate key, but not every candidate key is a primary key.\u201d - Always highlight minimality and uniqueness in candidate key definitions. - Use real-world fields like PAN, Aadhaar, Roll No to explain.</p>"},{"location":"dbms/#foreign-key","title":"Foreign Key","text":"<p>Definition: - A Foreign Key is an attribute (or set of attributes) in a table that references the Primary Key of another table or the same table. - Creates a link between two tables. - Ensures referential integrity. - Used in relational databases to maintain data consistency.</p> <p>Formal Definition: - A Foreign Key (FK) is a field in one table that refers to the Primary Key (PK) in another table. - It can:   - Be single or composite.   - Reference a simple or composite PK.</p> <p>Example Tables:</p> <p>Table: Student (Base / Referenced Table):</p> Roll_No (PK) Name Address 1 John Delhi 2 Priya Mumbai <p>Table: Course (Referencing Table):</p> Course_ID Course_Name Roll_No (FK) C101 DBMS 1 C102 OS 2 <ul> <li>Course.Roll_No is a foreign key referencing Student.Roll_No.</li> </ul> <p>Why Use Foreign Keys?: - To relate data across tables. - Prevent invalid data entry (e.g., you can't assign a course to a roll number that doesn\u2019t exist). - Maintains Referential Integrity.</p> <p>Common Interview Question: - Which key is used to maintain Referential Integrity?   - Answer: Foreign Key.</p> <p>Oracle SQL Syntax:</p> <p>While Creating Table:</p> <pre><code>CREATE TABLE Course (\n  Course_ID VARCHAR(10),\n  Course_Name VARCHAR(50),\n  Roll_No INT,\n  FOREIGN KEY (Roll_No) REFERENCES Student(Roll_No)\n);\n</code></pre> <p>After Table is Created (ALTER):</p> <pre><code>ALTER TABLE Course\nADD CONSTRAINT FK_Roll\nFOREIGN KEY (Roll_No)\nREFERENCES Student(Roll_No);\n</code></pre> <p>Important Points:</p> Concept Notes FK references PK of... Same or another table (usually another) Composite PK? Yes, FK can reference composite keys Name Match Required? \u274c No \u2014 column names can be different Multiple FKs per table? \u2705 Yes, a table can have multiple foreign keys Multiple PKs per table? \u274c No, only one Primary Key per table Data Types (FK &amp; PK) Must be same type (e.g., both INT) Nullability FK column can be null, unlike PK which must not be null <p>Keywords to Remember: - Referenced Table: Table that holds the PK (e.g., Student). - Referencing Table: Table that holds the FK (e.g., Course). - Referential Integrity: Ensures FK values exist in PK table.</p> <p>Mnemonic: - FK \u2192 PK: Foreign Key always Points to Primary Key. - R.F.R.: Referencing \u2192 Foreign Key \u2192 References \u2192 Referenced Table.</p>"},{"location":"dbms/#referential-integrity-operations","title":"Referential Integrity Operations","text":"<p>Referenced Table: Student:</p> Operation Will It Cause Problem? Why? Insert \u274c No You can add any student Delete \u26a0\ufe0f Maybe If that student is referenced in Course, \u2757problem! Update \u26a0\ufe0f Maybe If you update the PK, it breaks the link in child <p>Referencing Table: Course:</p> Operation Will It Cause Problem? Why? Insert \u26a0\ufe0f Maybe If RollNo doesn\u2019t exist in Student \u2192 \u274c Delete \u274c No You can remove the course for a student Update \u26a0\ufe0f Maybe Changing RollNo to one not in Student \u2192 \u274c <p>Solutions to Avoid Integrity Problems:</p> <ul> <li>ON DELETE CASCADE:</li> <li>If a student is deleted from Student table \u2192 their entry in Course will also be deleted.</li> <li>SQL:</li> </ul> <pre><code>FOREIGN KEY (RollNo) REFERENCES Student(RollNo) ON DELETE CASCADE\n</code></pre> <ul> <li>ON DELETE SET NULL:</li> <li>If student is deleted \u2192 RollNo in Course is set to NULL.</li> <li>Only works if RollNo in Course is not a Primary Key.</li> <li>SQL:</li> </ul> <pre><code>FOREIGN KEY (RollNo) REFERENCES Student(RollNo) ON DELETE SET NULL\n</code></pre> <ul> <li>ON DELETE NO ACTION (Default):</li> <li> <p>If RollNo is being referenced \u2192 you can\u2019t delete it from Student.</p> </li> <li> <p>Similarly for UPDATE:</p> </li> </ul> Option Meaning ON UPDATE CASCADE Updates RollNo everywhere automatically ON UPDATE SET NULL Sets foreign key to NULL ON UPDATE NO ACTION Prevents update if referenced <p>Real-Life Analogy: - Imagine a university:   - Student Table = Student Directory.   - Course Table = Enrollments.   - If you remove a student, you must remove or update all records showing them enrolled in courses.</p> <p>Summary:</p> Action Referenced Table (Student) Referencing Table (Course) Insert \u2705 Safe \u26a0\ufe0f May Violate FK Constraint Delete \u26a0\ufe0f May Violate RI \u2705 Safe Update \u26a0\ufe0f May Violate RI \u26a0\ufe0f May Violate FK Constraint <p>Key Terms Recap: - Foreign Key: Attribute pointing to a primary key in another table. - Referential Integrity: Ensures references between tables are valid. - ON DELETE/UPDATE CASCADE/SET NULL: Ways to automatically maintain data consistency.</p>"},{"location":"dbms/#super-key","title":"Super Key","text":"<p>Definition &amp; Concept: - A Super Key is any set of attributes that contains a Candidate Key and can still uniquely identify tuples. - Super Key \u2287 Candidate Key.</p> <p>Example: - If Roll No is a candidate key:   - Super Keys = { Roll No, (Roll No, Name), (Roll No, Email), (Roll No, Age, Name) ... } - Every super key must include at least one candidate key. - Set like (Name, Age) is NOT a super key if it doesn\u2019t guarantee uniqueness.</p> <p>Memory Tip: - Candidate = Clean &amp; Minimal. - Super = Super-set of candidate keys.</p>"},{"location":"dbms/#numerical-gate-style-mcq-concepts","title":"Numerical &amp; GATE-Style MCQ Concepts","text":"<p>Case 1: A1 is a Candidate Key: - All Super Keys = 2^(n-1). - Why?:   - Fix A1 (must include candidate key).   - Remaining (n-1) attributes \u2192 2 choices each: include/exclude.   - Total = 2^(n-1).</p> <p>Case 2: A1 and A2 are Candidate Keys: - All Super Keys = 2^(n-1) + 2^(n-1) - 2^(n-2). - Why?:   - A1\u2019s super keys: 2^(n-1).   - A2\u2019s super keys: 2^(n-1).   - Common sets (having both A1 and A2): 2^(n-2).   - Total = Add both and subtract common.</p> <p>Case 3: Two Composite Candidate Keys: - Let\u2019s say: Candidate keys: (A1, A2) and (A3, A4). - Total attributes = n. - Then:   - Super Keys from A1,A2 = 2^(n-2).   - Super Keys from A3,A4 = 2^(n-2).   - Common sets = 2^(n-4).   - Final = 2^(n-2) + 2^(n-2) - 2^(n-4).</p> <p>Practice MCQ (GATE-style): - Q: If relation R has 6 attributes and 2 candidate keys (A1, A2), how many super keys are possible? - Answer:   - 2^(6-1) + 2^(6-1) - 2^(6-2) = 32 + 32 - 16 = 48.</p>"},{"location":"dbms/#entity-relationship-er-model","title":"Entity-Relationship (ER) Model","text":""},{"location":"dbms/#purpose","title":"Purpose","text":"<ul> <li>Used for conceptual/logical data design before implementation.</li> <li>Like an architectural plan before constructing a building.</li> <li>Helps understand data structure before coding.</li> </ul> <p>Real-Life Analogy: - You draw a floor plan before building a house to avoid costly changes later. - In DBMS: You draw an ER diagram before writing SQL to avoid wrong design.</p>"},{"location":"dbms/#core-concepts","title":"Core Concepts","text":""},{"location":"dbms/#entity","title":"Entity","text":"<ul> <li>Definition: Anything that exists physically or logically and can be identified.</li> <li>Examples:</li> <li>Student, Course, Teacher, Department.</li> <li>Represented by a Rectangle in ER diagrams.</li> </ul>"},{"location":"dbms/#attribute","title":"Attribute","text":"<ul> <li>Definition: Properties or characteristics of an entity.</li> <li>Examples for Student:</li> <li>Roll No, Name, Age, Address.</li> <li>Represented by an Ellipse (Oval).</li> <li>Key attribute (e.g., Roll No) is underlined.</li> </ul>"},{"location":"dbms/#relationship","title":"Relationship","text":"<ul> <li>Definition: Association between two or more entities.</li> <li>Example:</li> <li>A Student studies a Course.</li> <li>Represented by a Diamond.</li> </ul>"},{"location":"dbms/#er-diagram-symbols","title":"ER Diagram Symbols","text":"Concept Symbol Example Entity \ud83d\udd32 Rectangle Student, Course Attribute \u2b55 Ellipse Name, Roll No Relationship \ud83d\udd37 Diamond Studies, Teaches Key Attribute \u2b55 Underlined Roll No <p>Why Use ER Model?: - Makes it easy to communicate with non-technical stakeholders. - Ensures clarity before coding. - Prevents rework if requirements change.</p> <p>Example ER Diagram:</p> <pre><code>[Insert ER Diagram Image Here]\n![](images/er_diagram.png)\n</code></pre> <p>Upcoming in ER Model Series: - Types of Attributes: Simple, Composite, Derived, Multivalued. - Types of Relationships / Cardinality: 1:1, 1:N, N:1, M:N.</p>"},{"location":"dbms/#types-of-attributes","title":"Types of Attributes","text":""},{"location":"dbms/#single-valued-vs-multi-valued-attributes","title":"Single-valued vs. Multi-valued Attributes","text":"Type Description Example ER Diagram Single-valued Only one value per entity instance Registration No, Age Normal (single) ellipse Multi-valued Multiple values per entity Phone Numbers, Addresses Double ellipse"},{"location":"dbms/#simple-vs-composite-attributes","title":"Simple vs. Composite Attributes","text":"Type Description Example ER Diagram Simple Atomic, cannot be divided Age, Roll No, Gender Single ellipse Composite Can be divided into subparts Name \u2192 First, Middle, Last; Address \u2192 City, State, ZIP Parent ellipse with subparts"},{"location":"dbms/#stored-vs-derived-attributes","title":"Stored vs. Derived Attributes","text":"Type Description Example ER Diagram Stored Directly saved in DB Date of Birth, Registration No Normal ellipse Derived Calculated from other data Age (derived from DOB) Dotted ellipse"},{"location":"dbms/#key-vs-non-key-attributes","title":"Key vs. Non-Key Attributes","text":"Type Description Example ER Diagram Key Uniquely identifies each entity Reg No, Roll No Underline the attribute Non-Key May not be unique Name, Father Name, Address Normal ellipse"},{"location":"dbms/#required-vs-optional-attributes-sql-side-concept-not-part-of-er-notation","title":"Required vs. Optional Attributes (SQL-side concept, not part of ER notation)","text":"Type Description Example Notes Required Cannot be null Student Name, Reg No Marked as NOT NULL in schema Optional Can be null Phone Number, Email May be skipped in input forms"},{"location":"dbms/#complex-attributes","title":"Complex Attributes","text":"<ul> <li>Combination of Composite + Multi-valued.</li> <li>Example: Address with multiple values, each containing Street, City, State.</li> <li>Represented using nested composite + multivalued ellipses.</li> </ul> <p>ER Diagram Notation Recap:</p> Attribute Type ER Symbol Single Simple ellipse Multi-valued Double ellipse Derived Dotted ellipse Key Underline Composite Parent with branches"},{"location":"dbms/#types-of-relationships-er-to-relational-model","title":"Types of Relationships (ER to Relational Model)","text":"<p>Overview:</p> Relationship Type ER Representation Real-World Example Table Reduction Possible? One to One (1:1) \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u20141\u2014\u2194\u20141\u2014\u2014\u2014\u2014\u2014\u2014\u2014 One employee \u2192 one department \u2705 Yes One to Many (1:N) \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u20141\u2014\u2194\u2014\u221e\u2014\u2014\u2014\u2014\u2014\u2014\u2014 One customer \u2192 many orders \u2705 Yes Many to Many (M:N) \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014M\u2014\u2194\u2014N\u2014\u2014\u2014\u2014\u2014\u2014\u2014 Many students \u2192 many courses \u274c No <p>What is a Relationship?: - A relationship shows association between two entities in an ER model. - Examples:   - Employee \u2194 Department.   - Customer \u2194 Order.   - Student \u2194 Course.</p>"},{"location":"dbms/#one-to-one-11","title":"One-to-One (1:1)","text":"<ul> <li>Example:</li> <li>An employee works in one department.</li> <li>A department has one employee managing it.</li> <li>Tables:</li> <li>Employee(EID, Name, Age) \u2192 EID is PK.</li> <li>Department(DID, DeptName, Location) \u2192 DID is PK.</li> <li>Works(EID, DID) \u2192 Relationship Table.</li> <li>Keys:</li> <li>EID and DID are both FKs in Works.</li> <li>Either EID or DID can be PK in Works.</li> <li>Special Point:</li> <li>If no duplication in EID or DID, then:<ul> <li>You can merge the relationship into either table.</li> </ul> </li> <li>Reduction:</li> <li>Final Tables: Employee + Department OR</li> <li>Merge: Employee(EID, Name, Age, DID) \u2192 2 tables total.</li> </ul>"},{"location":"dbms/#one-to-many-1n","title":"One-to-Many (1:N)","text":"<ul> <li>Example:</li> <li>A customer can place many orders.</li> <li>But each order is placed by only one customer.</li> <li>Tables:</li> <li>Customer(ID, Name, City) \u2192 ID is PK.</li> <li>Order(OrderNo, Item, Cost) \u2192 OrderNo is PK.</li> <li>Gives(ID, OrderNo, Date) \u2192 Relationship Table.</li> <li>Keys:</li> <li>ID and OrderNo are both FKs in Gives.</li> <li>But only OrderNo (on \"many\" side) is PK.</li> <li>Special Point:</li> <li>In 1:N, the PK of \"many\" side becomes PK in relationship.</li> <li>Reduction:</li> <li>Merge Gives + Order: Yes.</li> <li>Final Tables: Customer, Order(ID, OrderNo, Item, Cost, Date).</li> </ul>"},{"location":"dbms/#many-to-many-mn","title":"Many-to-Many (M:N)","text":"<ul> <li>Example:</li> <li>A student can enroll in many courses.</li> <li>A course can have many students.</li> <li>Tables:</li> <li>Student(RollNo, Name, Age) \u2192 RollNo is PK.</li> <li>Course(CID, Name, Credits) \u2192 CID is PK.</li> <li>Studies(RollNo, CID) \u2192 Relationship Table.</li> <li>Keys:</li> <li>RollNo and CID are both FKs.</li> <li>Together form a composite PK.</li> <li>Special Point:</li> <li>Cannot merge because neither RollNo nor CID is unique alone.</li> <li>Reduction:</li> <li>No reduction possible.</li> <li>Final Tables: Student, Course, Studies.</li> </ul> <p>Golden Rules Summary:</p> Case Relationship Table PK Merge Tables? 1:1 Either side (EID or DID) \u2705 Yes (pick any one side) 1:N PK of \"Many\" side (OrderNo) \u2705 Yes (merge with many) M:N Composite (RollNo + CID) \u274c No <p>Pro Tip for Exams: - \u201cWhere there is MANY, take that side\u2019s PK as the relationship table's PK.\u201d - \u201cIn reduction, always try merging on the MANY side.\u201d</p>"},{"location":"dbms/join/","title":"Joins in DBMS","text":"<p>Author: Abhinav P Pradeep </p>"},{"location":"dbms/join/#natural-join","title":"Natural Join","text":""},{"location":"dbms/join/#definition","title":"Definition","text":"<p>A Natural Join: - Automatically joins tables using all common attributes (i.e., same name and compatible data type). - Performs an equi join implicitly on those common columns. - Removes duplicate columns in the result.</p> <p>Join Concept: - Join = Cartesian Product (m \u00d7 n rows) + Matching rows based on some condition. - In Natural Join, the condition is: <code>WHERE Table1.common_column = Table2.common_column</code> (done implicitly).</p> <p>Syntax: <pre><code>SELECT column_list\nFROM Table1\nNATURAL JOIN Table2;\n</code></pre></p> <p>Condition: - The common column(s) must have the same name in both tables.</p>"},{"location":"dbms/join/#example","title":"Example","text":"<p>Tables:</p> <p>Employee Table:</p> EmpNo EmpName DeptNo 1 Ram 10 2 Varun 20 3 Ravi NULL 4 Amrit 30 <p>Department Table:</p> DeptNo DeptName 10 HR 20 IT 30 Marketing <p>Natural Join Query: <pre><code>SELECT EmpName, DeptName\nFROM Employee\nNATURAL JOIN Department;\n</code></pre></p> <p>Behind the Scenes: Equivalent to: <pre><code>SELECT EmpName, DeptName\nFROM Employee E, Department D\nWHERE E.DeptNo = D.DeptNo;\n</code></pre></p> <p>Result:</p> EmpName DeptName Ram HR Varun IT Amrit Marketing <p>Note: Ravi is excluded because his DeptNo is NULL (no matching department).</p>"},{"location":"dbms/join/#key-rules-of-natural-join","title":"Key Rules of Natural Join","text":"Rule Explanation Common columns must exist Columns should have same name &amp; data type Works like Equi Join But you don\u2019t specify condition manually Removes duplicate columns Only one copy of common column appears in output Ignores rows without match Works like inner join \u2014 no match \u2192 no output row"},{"location":"dbms/join/#real-world-scenarios","title":"Real-World Scenarios","text":"<ul> <li>Employee &amp; Department: Joining employees to their departments.</li> <li>Student &amp; Course: Linking student enrollment with course details.</li> <li>Customer &amp; Orders: Getting customer names with their orders.</li> </ul>"},{"location":"dbms/join/#if-column-names-differ","title":"If Column Names Differ","text":"<p>If Employee.DeptNo is named Dept_ID in one table and DeptNo in another, you cannot use Natural Join directly. Instead: - Rename column with alias or ALTER TABLE. - Or use Equi Join with an explicit condition.</p>"},{"location":"dbms/join/#exam-tip","title":"Exam Tip","text":"<p>Natural Join: - Automatic equi join. - On common column(s). - With column duplication removed. - No control over join condition manually.</p>"},{"location":"dbms/join/#equivalent-sql-forms","title":"Equivalent SQL Forms","text":"Natural Join Syntax Equivalent to This T1 NATURAL JOIN T2 T1 JOIN T2 ON T1.col = T2.col (for all common cols) T1 JOIN T2 USING (col) More explicit natural join on one column"},{"location":"dbms/join/#related-join-types","title":"Related Join Types","text":"Type Matching Unmatched Rows Duplicate Columns Natural Join Auto No Removed Inner Join Manual No Can stay Left Join Manual Yes (left) Can stay Right Join Manual Yes (right) Can stay Full Outer Manual Yes (both) Can stay"},{"location":"dbms/join/#equi-join","title":"Equi Join","text":""},{"location":"dbms/join/#definition_1","title":"Definition","text":"<p>An Equi Join: - Combines rows from two or more tables based on a condition involving equality (=). - The condition is usually on a common attribute (but can be on any comparable attribute). - Unlike Natural Join, duplicate columns are not removed. - Join = Cartesian Product + Selection Condition.</p>"},{"location":"dbms/join/#example-tables","title":"Example Tables","text":"<p>Employee Table:</p> EmpNo EmpName Address DeptNo 1 Ram Delhi 1 2 Varun Chandigarh 2 3 Ravi Mumbai NULL 4 Amrit Delhi 3 <p>Department Table:</p> DeptNo Location 1 Delhi 2 Pune 3 Patna <p>Question: Find the employee names who work in a department located in the same city as their address.</p>"},{"location":"dbms/join/#approach-with-equi-join","title":"Approach with Equi Join","text":"<p>Steps: 1. Use both tables: Employee (for names) and Department (for location). 2. Perform a Cartesian product (<code>FROM Employee, Department</code>). 3. Add two conditions:    - <code>Employee.DeptNo = Department.DeptNo</code> (ensures valid department mapping).    - <code>Employee.Address = Department.Location</code> (checks address = location).</p> <p>SQL Query: <pre><code>SELECT E.EmpName\nFROM Employee E, Department D\nWHERE E.DeptNo = D.DeptNo\n  AND E.Address = D.Location;\n</code></pre></p> <p>Output:</p> EmpName Ram <p>Explanation: - Ram (EmpNo 1) lives in Delhi, works in Dept 1 (Delhi) \u2192 Match. - Varun lives in Chandigarh, works in Dept 2 (Pune) \u2192 No match. - Ravi has no department \u2192 No match. - Amrit lives in Delhi, works in Dept 3 (Patna) \u2192 No match.</p>"},{"location":"dbms/join/#comparison-equi-join-vs-natural-join","title":"Comparison: Equi Join vs Natural Join","text":"Feature Equi Join Natural Join Condition syntax Manual: A.col = B.col Automatic on common columns Column duplication Retained Removed Flexibility High (join on any attribute) Limited to matching column names Query complexity Explicit Simpler for identical columns <p>Exam Tip: - Equi Join allows joining on any attribute using =. When joining on common keys, it becomes logically similar to Natural Join but with more control and retained duplicates.</p>"},{"location":"dbms/join/#outer-joins","title":"Outer Joins","text":""},{"location":"dbms/join/#left-outer-join-loj","title":"Left Outer Join (LOJ)","text":"<p>Definition: - Returns all matching rows (like Natural Join) + unmatched rows from the left table. - Adds NULL in columns from the right table where there\u2019s no match.</p> <p>Example:</p> <p>Employee Table (Left):</p> EmpNo EmpName DeptNo E1 Varun D1 E2 Amrit D2 E3 Ravi D1 E4 Nitin NULL <p>Department Table (Right):</p> DeptNo DeptName Location D1 IT Delhi D2 HR Hyd D3 Finance Pune D4 Testing Noida <p>Query: <pre><code>SELECT E.EmpNo, E.EmpName, D.DeptName, D.Location\nFROM Employee E\nLEFT OUTER JOIN Department D\nON E.DeptNo = D.DeptNo;\n</code></pre></p> <p>Output:</p> EmpNo EmpName DeptName Location E1 Varun IT Delhi E2 Amrit HR Hyd E3 Ravi IT Delhi E4 Nitin NULL NULL"},{"location":"dbms/join/#right-outer-join-roj","title":"Right Outer Join (ROJ)","text":"<p>Definition: - Returns all matching rows (like Natural Join) + unmatched rows from the right table. - Adds NULL in columns from the left table where there\u2019s no match.</p> <p>Query: <pre><code>SELECT E.EmpNo, E.EmpName, D.DeptName, D.Location\nFROM Employee E\nRIGHT OUTER JOIN Department D\nON E.DeptNo = D.DeptNo;\n</code></pre></p> <p>Output:</p> EmpNo EmpName DeptName Location E1 Varun IT Delhi E2 Amrit HR Hyd E3 Ravi IT Delhi NULL NULL Finance Pune NULL NULL Testing Noida"},{"location":"dbms/join/#full-outer-join-foj","title":"Full Outer Join (FOJ)","text":"<p>Definition: - Returns all rows from both tables (matched and unmatched). - Combines Left Outer Join + Right Outer Join. - NULL where no match is found in the opposite table.</p> <p>Query (Note: Not supported in MySQL directly): <pre><code>SELECT E.EmpNo, E.EmpName, D.DeptName, D.Location\nFROM Employee E\nFULL OUTER JOIN Department D\nON E.DeptNo = D.DeptNo;\n</code></pre></p> <p>Output:</p> EmpNo EmpName DeptName Location E1 Varun IT Delhi E2 Amrit HR Hyd E3 Ravi IT Delhi E4 Nitin NULL NULL NULL NULL Finance Pune NULL NULL Testing Noida"},{"location":"dbms/join/#venn-diagram-intuition","title":"Venn Diagram Intuition","text":"Join Type Covered Set Natural Join A \u2229 B Left Outer Join A \u2229 B + (A - B) Right Outer Join A \u2229 B + (B - A) Full Outer Join A \u222a B <p>Tips: - Left/Right Outer Join = Natural Join + unmatched from respective side. - Always consider which table is \u201cLEFT\u201d or \u201cRIGHT\u201d in the SQL query. - NULLs in output indicate no match in that side\u2019s table.</p>"},{"location":"dbms/norm/","title":"Normalization in DBMS","text":"<p>Author: Abhinav P Pradeep </p>"},{"location":"dbms/norm/#what-is-normalization","title":"What is Normalization?","text":"<p>Normalization is a technique in Database Management Systems (DBMS) used to remove or reduce redundancy (duplicate data) from a table.</p> <ul> <li>Redundancy: Repeated data.</li> <li>Goal: Better storage, faster updates, no data inconsistency.</li> </ul>"},{"location":"dbms/norm/#types-of-redundancy","title":"Types of Redundancy","text":""},{"location":"dbms/norm/#row-level-redundancy","title":"Row-Level Redundancy","text":"<ul> <li>Description: Same row repeated more than once.</li> <li>Example Table:</li> </ul> SID Name Age 1 Raj 20 2 Ravi 21 1 Raj 20 <ul> <li>Fix: Use a Primary Key (SID) to ensure:</li> <li>Uniqueness.</li> <li>Not Null.</li> <li>Result: Duplicate rows are not allowed.</li> </ul>"},{"location":"dbms/norm/#column-level-redundancy","title":"Column-Level Redundancy","text":"<ul> <li>Description: Same data repeated across columns in multiple rows.</li> <li>Example Table:</li> </ul> SID S.Name CID C.Name FID F.Name Salary 1 Raj C1 DBMS F1 Rahul 30000 2 Ravi C1 DBMS F1 Rahul 30000 3 Aman C2 OS F2 Neha 35000 <ul> <li>Problem: Course name, Faculty name, and Salary are repeated.</li> </ul>"},{"location":"dbms/norm/#anomalies-due-to-redundancy","title":"Anomalies Due to Redundancy","text":"<p>Anomalies are problems that arise due to bad table design.</p>"},{"location":"dbms/norm/#insertion-anomaly","title":"Insertion Anomaly","text":"<ul> <li>Issue: Cannot insert a new course or faculty without student info.</li> <li>Example: Want to insert:</li> <li>CID: C10</li> <li>C.Name: MBBS</li> <li>Problem: Cannot leave SID empty since it\u2019s a Primary Key, forcing fake/dummy data.</li> </ul>"},{"location":"dbms/norm/#deletion-anomaly","title":"Deletion Anomaly","text":"<ul> <li>Issue: Deleting a student may remove faculty/course info unintentionally.</li> <li>Example: Delete SID=2.</li> <li>Result: Also lose:</li> <li>Course C1.</li> <li>Faculty F1.</li> <li>Problem: Loss of critical info just by deleting one student.</li> </ul>"},{"location":"dbms/norm/#update-anomaly","title":"Update Anomaly","text":"<ul> <li>Issue: Updates need to happen in multiple rows manually.</li> <li>Example: Update F1\u2019s salary from 30000 to 40000.</li> <li>Problem: F1 appears in multiple rows, so must update all, which is prone to error and inconsistency.</li> </ul>"},{"location":"dbms/norm/#how-normalization-helps","title":"How Normalization Helps","text":"<p>Normalization breaks the big table into smaller, related tables using keys to avoid anomalies.</p> <p>Split into Three Tables:</p> <p>Student Table:</p> SID S.Name 1 Raj 2 Ravi <p>Course Table:</p> CID C.Name C1 DBMS C2 OS <p>Faculty Table:</p> FID F.Name Salary F1 Rahul 40000 F2 Neha 35000 <p>Benefits: - Insert new course/faculty directly. - Delete student without losing faculty/course info. - Update faculty salary in only one place.</p> <p>Primary Keys in Normalized Tables:</p> Table Primary Key Student SID Course CID Faculty FID <p>Summary Table:</p> Problem Cause Normalization Fix Insertion Anomaly Cannot insert partial info Split into independent tables Deletion Anomaly Unintended loss of data Maintain separate entity tables Update Anomaly Repetition causes inconsistency Update in only one location <p>Key Takeaways: - Normalize to avoid anomalies. - Use Primary Keys to uniquely identify rows. - Avoid storing repeated data in the same table. - Aim for a clean, modular table structure.</p>"},{"location":"dbms/norm/#closure-method","title":"Closure Method","text":""},{"location":"dbms/norm/#what-is-the-closure-method","title":"What is the Closure Method?","text":"<p>The Closure Method is used to find all Candidate Keys in a relation based on given Functional Dependencies (FDs).</p> <p>Why Important?: - Essential for 2NF, 3NF, BCNF. - Used in GATE, interviews, and real database design.</p>"},{"location":"dbms/norm/#key-definitions","title":"Key Definitions","text":"Term Meaning Closure (X\u207a) All attributes that can be functionally determined by X Candidate Key A minimal set of attributes whose closure includes all table attributes Super Key A set that includes a candidate key (can have extra attributes) Prime Attribute Used in any candidate key Non-Prime Attribute Not used in any candidate key"},{"location":"dbms/norm/#step-by-step-how-to-use-closure-method","title":"Step-by-Step: How to Use Closure Method","text":"<p>Goal: Find all candidate keys.</p> <p>Step 1: Identify All Functional Dependencies: - Example:   - Relation: R(A, B, C, D)   - FDs:     - A \u2192 B     - B \u2192 C     - C \u2192 D</p> <p>Step 2: Take Closure of Attributes: - A\u207a (Closure of A):   - A\u207a = A (reflexive).   - A \u2192 B \u2192 C \u2192 D (transitive).   - So, A\u207a = {A, B, C, D}.   - A\u207a contains all attributes \u2192 A is a Candidate Key. - B\u207a = {B, C, D} \u2192 Missing A, not a Candidate Key. - Similarly for C\u207a = {C, D}, D\u207a = {D}.</p> <p>Conclusion: - Candidate Key = {A}. - Prime Attribute = A. - Non-Prime = {B, C, D}.</p> <p>Trick to Identify Key Candidates Quickly: - Any attribute NOT on the RHS of any FD must be in every Candidate Key. - Example:   - FDs:     - A \u2192 B     - B \u2192 D     - E \u2192 C     - C \u2192 A   - RHS: B, D, C, A \u2192 E is not on RHS.   - E must be part of the candidate key.</p>"},{"location":"dbms/norm/#more-examples","title":"More Examples","text":"<p>Example 1: - Relation: R(A, B, C, D) - FDs:   - AB \u2192 C   - B \u2192 C   - C \u2192 D   - D \u2192 A - Closure:   - A\u207a = {A, B, C, D} \u2192 Candidate Key.   - B\u207a = {B, C, D, A} \u2192 Candidate Key.   - C\u207a = {C, D, A, B} \u2192 Candidate Key.   - D\u207a = {D, A, B, C} \u2192 Candidate Key. - Result:   - Candidate Keys: A, B, C, D.   - Prime Attributes: A, B, C, D.   - Non-Prime: \u2205 (phi).</p> <p>Example 2: - Relation: R(A, B, C, D, E) - FDs:   - A \u2192 B   - BC \u2192 D   - D \u2192 A   - E \u2192 C - Tip: RHS = {B, D, A, C} \u2192 E not present, so E must be in every candidate key. - Closure:   - E\u207a = {E, C} \u2192 Not enough.   - AE\u207a:     - A \u2192 B     - E \u2192 C     - BC \u2192 D     - D \u2192 A     - AE\u207a = {A, B, C, D, E} \u2192 Candidate Key.   - Try DE, BE, CE:     - DE\u207a = {D, E, C, A, B} \u2192 Candidate Key.     - BE\u207a = {B, E, C, D, A} \u2192 Candidate Key. - Result:   - Candidate Keys: AE, DE, BE.   - Prime Attributes: A, B, D, E.   - Non-Prime: C.</p>"},{"location":"dbms/norm/#functional-dependency-fd","title":"Functional Dependency (FD)","text":""},{"location":"dbms/norm/#what-is-a-functional-dependency","title":"What is a Functional Dependency?","text":"<p>Functional Dependency describes the relationship between attributes in a relation (table). It shows how one attribute (or group of attributes) can determine another.</p> <p>Format: - X \u2192 Y   - X: Determinant attribute(s).   - Y: Dependent attribute(s).   - Meaning: \"X determines Y\" or \"Y is functionally dependent on X\".</p> <p>Example: - Relation: Student(SID, S.Name) - FD: SID \u2192 S.Name - Meaning:   - One SID determines one S.Name.   - Same name may occur with different SIDs.   - Use SID to remove ambiguity in names like \"Ranjit\".</p> <p>Valid &amp; Invalid FD Cases:</p> Case # S.Name (Y) SID (X) Valid/Invalid Explanation 1 Ranjit, Ranjit 1, 1 \u2705 Valid Same SID, repeated entry 2 Ranjit, Ranjit 1, 2 \u2705 Valid Two different students with same name 3 Ranjit, Varun 1, 2 \u2705 Valid Two different students 4 Ranjit, Varun 1, 1 \u274c Invalid One SID cannot determine two different names <ul> <li>If the determinant (LHS) is the same but the dependent (RHS) differs \u2192 Invalid FD.</li> </ul>"},{"location":"dbms/norm/#types-of-functional-dependencies","title":"Types of Functional Dependencies","text":""},{"location":"dbms/norm/#trivial-functional-dependency","title":"Trivial Functional Dependency","text":"<ul> <li>X \u2192 Y is trivial if Y \u2286 X.</li> <li>Always valid.</li> <li>Examples:</li> <li>SID \u2192 SID</li> <li>{SID, S.Name} \u2192 SID</li> <li>Intersection Rule:</li> <li>If X \u2229 Y \u2260 \u2205 \u2192 Trivial FD.</li> </ul>"},{"location":"dbms/norm/#non-trivial-functional-dependency","title":"Non-Trivial Functional Dependency","text":"<ul> <li>X \u2192 Y is non-trivial if Y \u2288 X.</li> <li>Requires validation.</li> <li>Examples:</li> <li>SID \u2192 S.Name</li> <li>EmpID \u2192 EmpName, City</li> <li>Intersection Rule:</li> <li>If X \u2229 Y = \u2205 \u2192 Non-Trivial FD.</li> </ul>"},{"location":"dbms/norm/#properties-of-functional-dependency","title":"Properties of Functional Dependency","text":"Property Rule Notes Reflexivity If Y \u2286 X, then X \u2192 Y Always true Augmentation If X \u2192 Y, then XZ \u2192 YZ Add same attribute to both sides Transitivity If X \u2192 Y and Y \u2192 Z, then X \u2192 Z Very important Union If X \u2192 Y and X \u2192 Z, then X \u2192 YZ Combine RHS Decomposition If X \u2192 YZ, then X \u2192 Y and X \u2192 Z Decompose RHS only Pseudo-Transitivity If X \u2192 Y and WY \u2192 Z, then WX \u2192 Z Mix rules Composition If X \u2192 Y and Z \u2192 W, then XZ \u2192 YW Combine both sides <p>Important Rule: - Never decompose LHS. For example:   - \u274c XY \u2192 Z \u21d2 X \u2192 Z or Y \u2192 Z (Not always valid!).</p> <p>Summary:</p> Concept Quick Tip Functional Dependency X \u2192 Y means X determines Y Valid FD One value of X \u2192 One value of Y Invalid FD One value of X \u2192 Multiple values of Y Trivial FD Y \u2286 X Non-Trivial FD Y \u2288 X Validate FDs Only for non-trivial ones Reflexivity &amp; Transitivity Most used in exams &amp; practice"},{"location":"dbms/norm/#normal-forms","title":"Normal Forms","text":""},{"location":"dbms/norm/#first-normal-form-1nf","title":"First Normal Form (1NF)","text":"<p>Definition: A relation (table) is in 1NF if: 1. All attributes contain only atomic (indivisible) values. 2. There are no repeating groups or multivalued attributes.</p> <p>In Simple Words: - Every cell in the table should hold only one value, not lists, sets, or groups.</p> <p>Example: Not in 1NF:</p> StudentID Name Courses 101 Alice DBMS, OS, Networks 102 Bob DBMS, DSA <p>Violation: - Column Courses has multiple values in a single cell (not atomic).</p> <p>Converted to 1NF:</p> StudentID Name Course 101 Alice DBMS 101 Alice OS 101 Alice Networks 102 Bob DBMS 102 Bob DSA <p>Now: - Each cell contains a single value. - No multivalued columns. - Table is in 1NF.</p> <p>Common Mistakes That Violate 1NF:</p> Violation Example Multivalued attributes Courses = Composite values in one cell Name = John, Smith Repeating columns Phone1, Phone2, Phone3 <p>Quick Checklist for 1NF:</p> Check Passes 1NF? Does every attribute contain atomic values? \u2705 Yes Any attribute storing multiple values? \u274c No Any repeating columns (e.g., Phone1, Phone2)? \u274c No <p>Mnemonic: - \"1 Cell = 1 Value\" \u2192 That\u2019s 1NF.</p>"},{"location":"dbms/norm/#second-normal-form-2nf","title":"Second Normal Form (2NF)","text":"<p>Definition: A table is in Second Normal Form (2NF) if: 1. The table is in First Normal Form (1NF). 2. No Partial Dependency exists.</p> <p>Key Definitions: - Partial Dependency: A non-prime attribute is partially dependent on a candidate key if it\u2019s dependent on a subset (proper part) of a composite candidate key.   - Only applies when the candidate key is composite (has 2 or more attributes).   - A non-prime attribute depends only on part of that key. - Prime Attribute: An attribute that is part of a candidate key. - Non-Prime Attribute: An attribute that is not part of any candidate key.</p> <p>2NF Rule (In Simple Words): - All non-prime attributes should be fully functionally dependent on the entire candidate key, not just a part of it.</p> <p>Step-by-Step Check for 2NF: 1. Check for 1NF:    - No multivalued or repeating attributes. 2. Identify Candidate Key(s):    - Use Closure Method to find candidate keys. 3. List Prime &amp; Non-Prime Attributes:    - Prime: Used in forming candidate key.    - Non-Prime: Everything else. 4. Check Functional Dependencies:    - If LHS is a proper subset of a candidate key and RHS is a non-prime attribute \u2192 Partial Dependency.    - If even one partial dependency exists \u2192 Table not in 2NF.</p> <p>Example: Customer Table:</p> CustomerID StoreID Location 1 1 Delhi 2 1 Delhi 3 2 Bangalore 4 3 Mumbai <p>FDs: - Candidate Key: {CustomerID, StoreID} - FD: StoreID \u2192 Location</p> <p>Check: - Location is a non-prime attribute. - StoreID is a part of the candidate key. - Location is partially dependent. - Result: Not in 2NF.</p> <p>To Convert to 2NF: - Break into two tables:   1. Customer Table:</p> CustomerID StoreID 1 1 2 1 3 2 4 3 <ol> <li>Store Table:</li> </ol> StoreID Location 1 Delhi 2 Bangalore 3 Mumbai <p>Now: - Location is dependent on the full key (StoreID). - No partial dependencies remain.</p> <p>GATE Question Example: - Relation: R(A, B, C, D, E, F) - FDs:   1. C \u2192 F   2. E \u2192 A   3. EC \u2192 D   4. A \u2192 B - Step 1: Candidate Key:   - RHS attributes = {F, A, D, B}.   - LHS = EC must be key (closure of EC \u2192 all attributes).   - Candidate Key = EC. - Step 2: Prime / Non-Prime Attributes:   - Prime: E, C.   - Non-Prime: A, B, D, F. - Step 3: Check for Partial Dependencies:</p> FD LHS Subset of Key? RHS Non-Prime? Result C \u2192 F \u2705 Yes \u2705 Yes \u274c Partial Dependency E \u2192 A \u2705 Yes \u2705 Yes \u274c Partial Dependency EC \u2192 D \u274c No (full key) \u2705 Yes \u2705 Full Dependency A \u2192 B \u274c A is non-prime \u2705 Yes Not partial (violates 3NF) <ul> <li>Result: Table is not in 2NF due to partial dependencies.</li> </ul> <p>Tips to Remember:</p> Concept Tip 2NF Condition No partial dependency Check for partial dep. LHS \u2282 candidate key &amp; RHS is non-prime Happens only if key is composite True Fixing partial dependencies Decompose the table Minimum requirement Table must be in 1NF"},{"location":"dbms/norm/#third-normal-form-3nf-ef-codds-rules","title":"Third Normal Form (3NF) \u2014 E.F. Codd\u2019s Rules","text":"<p>Definition: A relation is in 3NF if: 1. It is already in Second Normal Form (2NF). 2. No transitive dependency exists for non-prime attributes.</p> <p>What is a Transitive Dependency?: - Occurs if: A \u2192 B \u2192 C.   - A is a candidate key.   - B is a non-prime attribute.   - C is a non-prime attribute. - Problem: A non-prime (C) is determined by another non-prime (B) \u2014 not allowed in 3NF.</p> <p>Key Definitions:</p> Term Meaning Prime Attribute Part of any candidate key Non-Prime Attribute Not part of any candidate key Transitive Dependency Non-prime \u2192 non-prime (indirectly via key) <p>Most Practical Condition to Check 3NF: - For every functional dependency (FD): X \u2192 Y - At least one of the following must be true:   1. X is a super key.   2. Y is a prime attribute. - This is the golden rule for solving MCQs or exam problems.</p> <p>Example 1: - Relation: Student(RollNo, State, City) - FDs:   - RollNo \u2192 State   - State \u2192 City - Analysis:   - RollNo = candidate key (prime).   - State, City = non-prime.   - State \u2192 City = transitive dependency (non-prime \u2192 non-prime). - Result: Not in 3NF.</p> <p>Example 2: - Relation: R(A, B, C, D) - FDs:   - AB \u2192 C   - C \u2192 D - Candidate Key: AB   - AB \u2192 C (valid: key \u2192 non-prime).   - C \u2192 D (invalid: non-prime \u2192 non-prime). - Result: Not in 3NF.</p> <p>Example 3 (Valid 3NF): - Relation: R(A, B, C, D) - FDs:   - AB \u2192 CD   - D \u2192 A - Candidate Keys: AB, DB - Prime Attributes: A, B, D - Non-Prime Attribute: C - Check each FD:   - AB \u2192 CD (valid: AB is a candidate key).   - D \u2192 A (valid: A is prime attribute). - Result: This is in 3NF.</p> <p>Summary to Remember 3NF:</p> What to Check Valid for 3NF? Non-prime \u2192 Non-prime (transitive) \u274c Invalid Key \u2192 Non-prime \u2705 Valid Non-prime \u2192 Prime \u2705 Valid Key \u2192 Anything \u2705 Valid Prime \u2192 Prime \u2705 Valid <p>Tip: - Only one rule to remember: \"For every FD X \u2192 Y, X must be a superkey or Y must be a prime attribute.\"</p>"},{"location":"dbms/norm/#boyce-codd-normal-form-bcnf","title":"Boyce-Codd Normal Form (BCNF)","text":"<p>What is BCNF?: - A stricter version of 3NF, sometimes called 3.5NF. - Every BCNF-compliant table is also in 3NF, but not all 3NF tables are in BCNF.</p> <p>Condition for BCNF: - For every functional dependency X \u2192 Y, X must be a candidate key (or a super key). - Unlike 3NF, BCNF does not allow:   - X being non-key (even if Y is a prime attribute).   - Any dependency where LHS is not a candidate key.</p> <p>Steps to Check BCNF: 1. Table must already be in 3NF. 2. For each FD, check:    - Is the LHS a candidate key or super key?    - If yes \u2192 FD is valid in BCNF.    - If no \u2192 Table is not in BCNF.</p> <p>Example: - Student Table:   - Attributes: RollNo, Name, VoterID, Age   - FDs:     - RollNo \u2192 Name     - RollNo \u2192 VoterID     - VoterID \u2192 Age     - VoterID \u2192 RollNo   - Candidate Keys: RollNo, VoterID   - Both can uniquely identify a student. - BCNF Check:</p> FD LHS Is Candidate Key? Valid in BCNF? RollNo \u2192 Name RollNo \u2705 Yes \u2705 Valid RollNo \u2192 VoterID RollNo \u2705 Yes \u2705 Valid VoterID \u2192 Age VoterID \u2705 Yes \u2705 Valid VoterID \u2192 RollNo VoterID \u2705 Yes \u2705 Valid <ul> <li>Conclusion: All LHS are candidate keys \u2192 Table is in BCNF.</li> </ul> <p>BCNF vs 3NF: Core Difference:</p> Feature 3NF BCNF Condition LHS is a super key OR RHS is a prime attribute LHS must be a super key/candidate key Handles anomalies Yes Yes, but better than 3NF All 3NF \u21d2 BCNF? \u274c Not always \u2705 All BCNF are in 3NF Example Violation Case If LHS is not a super key but RHS is prime Such case is not allowed in BCNF <p>Normal Forms Relationship: - BCNF \u2282 3NF \u2282 2NF \u2282 1NF - Visual Tip:   - Imagine each normal form as a circle inside another.   - BCNF is the deepest and strictest.</p> <p>Common Interview Questions: - Q1: Is every 3NF table in BCNF? \u2192 \u274c No - Q2: Is every BCNF table in 3NF? \u2192 \u2705 Yes - Q3: What\u2019s the key condition for BCNF? \u2192 LHS of every FD must be a candidate key</p>"},{"location":"dbms/norm/#example-normalizing-a-table","title":"Example: Normalizing a Table","text":"<p>0NF (Unnormalized Form):</p> RollNo Name Courses Dept HOD 101 Alice DBMS, OS CSE Dr. Rao 102 Bob DBMS, Networks CSE Dr. Rao <p>Issue: Courses is multivalued, cells are not atomic.</p> <p>1NF \u2014 Remove Multivalued Attributes:</p> RollNo Name Course Dept HOD 101 Alice DBMS CSE Dr. Rao 101 Alice OS CSE Dr. Rao 102 Bob DBMS CSE Dr. Rao 102 Bob Networks CSE Dr. Rao <p>Now: - All attributes are atomic. - No repeating or multivalued fields.</p> <p>2NF \u2014 Remove Partial Dependencies: - Candidate Key: (RollNo, Course) - Partial dependency: RollNo \u2192 Name, Dept - Break into two tables:   1. Enrollment Table:</p> RollNo Course 101 DBMS 101 OS 102 DBMS 102 Networks <ol> <li>Student Table:</li> </ol> RollNo Name Dept 101 Alice CSE 102 Bob CSE <p>Now: - Every non-prime attribute fully depends on the whole key. - No partial dependencies.</p> <p>3NF \u2014 Remove Transitive Dependencies: - FD: Dept \u2192 HOD (transitive via RollNo \u2192 Dept). - Break again:   - Department Table:</p> Dept HOD CSE Dr. Rao IT Dr. Iyer <p>Final Tables after 3NF: 1. Enrollment(RollNo, Course) 2. Student(RollNo, Name, Dept) 3. Department(Dept, HOD)</p> <p>Now: - No transitive dependencies. - All non-prime attributes directly depend on candidate keys.</p> <p>Why BCNF is Needed (Even After 3NF): - 3NF allows: \"If RHS is a prime attribute, the LHS can be non-key.\" - This is dangerous because it allows functional control from a non-superkey.</p> <p>Classic Example Where 3NF Fails:</p> Student Course Instructor A DBMS Rao B DBMS Rao A OS Rao <p>FDs: - Student, Course \u2192 Instructor (valid: candidate key). - Instructor \u2192 Course (invalid: not OK!).</p> <p>Why It Fails in 3NF: - Instructor \u2192 Course:   - LHS = not a candidate key.   - RHS (Course) = prime \u2192 3NF valid.   - But Instructor decides part of the key \u2192 BAD DESIGN. - Result: In 3NF, but not in BCNF.</p> <p>Fix with BCNF: Decompose: 1. InstructorCourse Table:</p> Instructor Course Rao DBMS Rao OS <ol> <li>StudentInstructor Table:</li> </ol> Student Instructor A Rao B Rao <p>Now: - All FDs obey: LHS is a superkey in their table. - This is BCNF compliant.</p> <p>Summary Table:</p> Normal Form Problem Fixed Rule 1NF Multivalued attributes Atomic values only (no sets/lists in a cell) 2NF Partial dependency Full functional dependency on entire key 3NF Transitive dependency Non-prime depends only on superkey directly BCNF Non-superkey determinants Every determinant is a superkey"},{"location":"dbms/trans/","title":"Transactions and Schedules in DBMS","text":"<p>Author: Abhinav P Pradeep </p>"},{"location":"dbms/trans/#transactions","title":"Transactions","text":""},{"location":"dbms/trans/#what-is-a-transaction","title":"What is a Transaction?","text":"<p>A transaction is a set of operations performed together to complete a logical unit of work on a database.</p> <p>Real-Life Analogy: - ATM Withdrawal - Online Fund Transfer - Both involve multiple steps but result in one complete task.</p> <p>ATM Example \u2013 Transaction Steps:</p> Step Action 1 Insert ATM Card 2 Card Info is read from DB 3 Choose language, account type 4 Enter amount 5 Enter PIN 6 Cash dispensed 7 SMS confirmation sent 8 Final Message: \u201cTransaction Successful\u201d <p>Note: All these steps together form one transaction.</p>"},{"location":"dbms/trans/#database-transaction-definition","title":"Database Transaction Definition","text":"<p>A transaction changes the database or reads data from it.</p> <p>Operations in a DB Transaction: 1. Read(A): Access data from DB (hard disk \u2192 RAM). 2. Write(A): Modify data in RAM. 3. Commit: Save changes permanently to hard disk.</p> <p>Online Transaction Example:</p> Step DB Operation Login (username + password) Read Select Beneficiary Read Enter amount + OTP + transaction password Write Final Confirmation Commit"},{"location":"dbms/trans/#detailed-db-transaction-example","title":"Detailed DB Transaction Example","text":"<p>Scenario: Transfer \u20b9500 from A (\u20b91000) to B (\u20b92000).</p> <p>Step-by-Step Breakdown:</p> Step DB Action RAM Value Notes 1 Read(A) A = 1000 Fetched from DB to RAM 2 A = A - 500 A = 500 Arithmetic Op in RAM 3 Write(A) A updated in RAM DB unchanged yet 4 Read(B) B = 2000 From DB to RAM 5 B = B + 500 B = 2500 Arithmetic Op in RAM 6 Write(B) B updated in RAM DB unchanged yet 7 Commit A=500, B=2500 in DB Permanent Save <p>Note: CPU never directly works on disk; it uses RAM for operations.</p>"},{"location":"dbms/trans/#summary-of-key-operations","title":"Summary of Key Operations","text":"Operation Meaning Read(X) Fetch data from DB to RAM Write(X) Change value in RAM Commit Save changes to DB permanently Rollback Undo uncommitted changes"},{"location":"dbms/trans/#core-concept","title":"Core Concept","text":"<p>A transaction consists of Read, Write, and Commit (or Rollback) operations, ensuring: - All-or-Nothing Execution. - Data remains consistent. - Reliability in systems like banking, e-commerce, etc.</p>"},{"location":"dbms/trans/#acid-properties-of-transactions","title":"ACID Properties of Transactions","text":"<p>ACID: Atomicity + Consistency + Isolation + Durability.</p> <p>These properties ensure safe, correct, and reliable transaction handling in DBMS.</p> <p>Why ACID Properties?: - Backend developers enforce them to ensure correctness and reliability in systems like Paytm, BHIM, or ATMs.</p>"},{"location":"dbms/trans/#1-atomicity-all-or-none","title":"1. Atomicity \u2013 \u201cAll or None\u201d","text":"<p>Meaning: - A transaction must either complete fully or fail completely (no partial changes allowed).</p> <p>Real-Life Analogy (ATM): - You inserted card, selected amount, entered PIN, but internet drops after OTP. - DBMS rolls back the entire transaction. - No \u201c90% done\u201d \u2014 it starts from scratch next time.</p> <p>Key Concept: - If a transaction has 100 operations and fails at 99, ALL 99 are undone. - A failed transaction never resumes; it always restarts.</p>"},{"location":"dbms/trans/#2-consistency-data-valid-before-and-after","title":"2. Consistency \u2013 \u201cData Valid Before and After\u201d","text":"<p>Meaning: - The total data (e.g., total money) must remain valid before and after the transaction.</p> <p>Example: - Before: A = \u20b92000, B = \u20b93000 \u2192 Total = \u20b95000. - Transaction: Transfer \u20b91000 from A to B. - After: A = \u20b91000, B = \u20b94000 \u2192 Total = \u20b95000 (Consistent).</p> <p>Inconsistent Case: - Internet lost after ATM processing. - \u20b95000 debited from account, but no cash received. - DB becomes inconsistent. - Consistency ensures database rules are never violated.</p>"},{"location":"dbms/trans/#3-isolation-no-interference-between-transactions","title":"3. Isolation \u2013 \u201cNo Interference Between Transactions\u201d","text":"<p>Meaning: - Each transaction should run as if it\u2019s the only one in the system.</p> <p>Real-World Scenario: - T1 reads A. - Meanwhile, T2 writes to A. - T1 now sees inconsistent/partial data.</p> <p>Conceptual Goal: - Convert a parallel schedule (T1 \u2192 T2 \u2192 T1 \u2192 T2 \u2192 T1) into a serial one (T1 \u2192 T2 or T2 \u2192 T1). - If possible \u2192 Isolation is preserved. - If not \u2192 Data inconsistency may occur.</p> <p>Note: Explored further in Conflict/View Serializability.</p>"},{"location":"dbms/trans/#4-durability-once-committed-forever-saved","title":"4. Durability \u2013 \u201cOnce Committed, Forever Saved\u201d","text":"<p>Meaning: - Once a transaction commits, the changes must be permanent and survive system failures, power off, etc.</p> <p>Analogy: - You save a movie in D: drive. - Next day, laptop boots up \u2192 movie is still there.</p> <p>In DBMS: - If A = \u20b91000 and B = \u20b94000 after a transaction, restarting the server tomorrow must still show A = 1000, B = 4000. - Durability is achieved by saving data to non-volatile storage (like hard disk).</p>"},{"location":"dbms/trans/#summary-table","title":"Summary Table","text":"Property Key Idea Real-Life Analogy Atomicity All or none ATM transaction fails \u2192 starts from scratch Consistency DB remains valid Money in account + cash withdrawn = original total Isolation No interference Each transaction acts like it\u2019s alone Durability Permanent changes Saved file stays on disk even after restart"},{"location":"dbms/trans/#mini-quiz","title":"Mini Quiz","text":"<ol> <li>What happens if a transaction fails after 99 operations?</li> <li>If A=2000, B=3000 before, and after transaction A=1000, B=4000 \u2014 is consistency preserved?</li> <li>Can we rearrange a parallel transaction schedule into a serial one? Why?</li> <li>What ensures that transaction changes stay even after a crash?</li> </ol> <p>Answers: 1. Entire transaction rolls back \u2014 nothing is saved. 2. Yes, because total remains 5000 \u2192 Consistency preserved. 3. Yes, if it\u2019s serializable, isolation is achieved. 4. Durability \u2014 by saving to hard disk.</p>"},{"location":"dbms/trans/#transaction-states-in-dbms","title":"Transaction States in DBMS","text":"<p>When a transaction is executed in a DBMS, it goes through the following states:</p>"},{"location":"dbms/trans/#1-active-state","title":"1. Active State","text":"<ul> <li>The transaction has started and is performing read/write operations.</li> <li>Example: Reading data from the database and doing calculations like A = A - 50.</li> <li>Data is in RAM (volatile memory).</li> <li>Transition: After performing all operations except commit \u2192 moves to Partially Committed.</li> </ul>"},{"location":"dbms/trans/#2-partially-committed-state","title":"2. Partially Committed State","text":"<ul> <li>All operations except the final commit are successfully executed.</li> <li>Changes are still in RAM, not in the permanent database.</li> <li>One last step (COMMIT) remains to make changes permanent.</li> </ul>"},{"location":"dbms/trans/#3-committed-state","title":"3. Committed State","text":"<ul> <li>The commit operation has been executed.</li> <li>All changes made by the transaction are now saved permanently in the hard disk (non-volatile storage).</li> <li>The transaction is safe, even if the system crashes after this.</li> </ul>"},{"location":"dbms/trans/#4-failed-state","title":"4. Failed State","text":"<ul> <li>The transaction has encountered an error before commit.</li> <li>Causes: Power failure, network issues, system crash, user mistake (e.g., refreshing payment page).</li> <li>Example: You entered OTP, but clicked refresh \u2192 transaction failed.</li> </ul>"},{"location":"dbms/trans/#5-aborted-state","title":"5. Aborted State","text":"<ul> <li>A failed transaction is aborted.</li> <li>Rollback happens: All changes are undone to maintain consistency.</li> <li>The transaction cannot resume; it must restart from the beginning.</li> <li>After abort: Transaction can either be terminated or restarted later.</li> </ul>"},{"location":"dbms/trans/#6-terminated-state","title":"6. Terminated State","text":"<ul> <li>The transaction has successfully finished or been aborted.</li> <li>All resources (CPU, RAM, network, locks, etc.) are deallocated.</li> <li>It is now removed from the system.</li> </ul>"},{"location":"dbms/trans/#important-notes","title":"Important Notes","text":"<ul> <li>After commit, a transaction cannot fail.</li> <li>Rollback is only possible before commit.</li> <li>No partial execution is allowed (atomicity).</li> <li>In real systems like ATM, IRCTC, or UPI apps, these states ensure data correctness and consistency even in failure scenarios.</li> </ul>"},{"location":"dbms/trans/#dbms-schedules-serial-vs-parallel","title":"DBMS Schedules: Serial vs Parallel","text":""},{"location":"dbms/trans/#what-is-a-schedule","title":"What is a Schedule?","text":"<p>A schedule is a chronological sequence that defines how multiple transactions are executed in a DBMS. - Example: T1, T2, T3 are transactions. A schedule tells the order in which their operations occur.</p>"},{"location":"dbms/trans/#types-of-schedules","title":"Types of Schedules","text":""},{"location":"dbms/trans/#1-serial-schedule","title":"1. Serial Schedule","text":"<ul> <li>One transaction at a time \u2014 no interleaving.</li> <li>Execution Flow:</li> <li>T1 executes completely \u2192 then T2 \u2192 then T3.</li> <li>No switching between transactions during execution.</li> <li>Advantages:</li> <li>Consistency guaranteed (no interference).</li> <li>Easy to understand and debug.</li> <li>Disadvantages:</li> <li>High waiting time for other transactions.</li> <li>Low performance and low throughput.</li> <li>Real-Life Analogy:</li> <li>ATM machine with a queue: One person uses it at a time, others wait.</li> </ul>"},{"location":"dbms/trans/#2-parallel-schedule-interleaved-schedule","title":"2. Parallel Schedule (Interleaved Schedule)","text":"<ul> <li>Multiple transactions execute concurrently (interleaved steps).</li> <li>Execution Flow:</li> <li>T1, T2, T3 may start at the same time.</li> <li>CPU switches between transactions (context switching).</li> <li>Advantages:</li> <li>High performance.</li> <li>Better CPU utilization.</li> <li>High throughput: More transactions per unit time.</li> <li>Disadvantages:</li> <li>May lead to inconsistency if not managed properly.</li> <li>Requires concurrency control (e.g., conflict serializability, recoverability).</li> <li>Real-Life Analogy:</li> <li>Online banking/IRCTC website: Many users transacting at the same time.</li> <li>System handles thousands of users concurrently.</li> </ul>"},{"location":"dbms/trans/#throughput-performance","title":"Throughput &amp; Performance","text":"<ul> <li>Throughput: Number of transactions completed per unit time.</li> <li>More parallelism \u2192 More throughput \u2192 Better performance.</li> </ul>"},{"location":"dbms/trans/#summary-table_1","title":"Summary Table","text":"Feature Serial Schedule Parallel Schedule Execution One at a time Interleaved Waiting time High Low Performance Low High Consistency High (guaranteed) May be inconsistent Real-world analogy ATM queue IRCTC / Online banking"},{"location":"dbms/trans/#key-takeaway","title":"Key Takeaway","text":"<ul> <li>Today\u2019s DBMS systems rely on parallel schedules due to user demand for high performance and speed.</li> <li>To ensure correctness, concurrency control mechanisms (e.g., serializability, locking) are required.</li> </ul>"},{"location":"oops/oops/","title":"Object-Oriented Programming (OOP) Concepts","text":"<p>Author: Abhinav P Pradeep </p>","tags":["OOPS","theory"]},{"location":"oops/oops/#classes-and-objects","title":"Classes and Objects","text":"","tags":["OOPS","theory"]},{"location":"oops/oops/#what-is-a-class","title":"What is a Class?","text":"<ul> <li>Building Block of OOP: The foundational element in object-oriented programming.</li> <li>User-defined Data Type: A class is a template that defines data members (attributes) and member functions (methods).</li> <li>Blueprint and Logical Representation: A class provides the structure and behavior but doesn't hold data itself until instantiated.</li> </ul> <pre><code>class Car {\npublic:\n    string brand;\n    string model;\n    int year;\n\n    void displayInfo() {\n        cout &lt;&lt; \"Brand: \" &lt;&lt; brand &lt;&lt; \", Model: \" &lt;&lt; model &lt;&lt; \", Year: \" &lt;&lt; year &lt;&lt; endl;\n    }\n};\n</code></pre> <ul> <li>Member Function Outside/Inside Class: You can define member functions inside or outside the class.</li> </ul> <p>Outside Example:</p> <pre><code>void Car::displayInfo() {\n    cout &lt;&lt; \"Brand: \" &lt;&lt; brand &lt;&lt; \", Model: \" &lt;&lt; model &lt;&lt; \", Year: \" &lt;&lt; year &lt;&lt; endl;\n}\n</code></pre> <ul> <li>Data Member: Always defined inside the class.</li> </ul>","tags":["OOPS","theory"]},{"location":"oops/oops/#what-is-an-object","title":"What is an Object?","text":"<ul> <li>Instance of a Class: An object is a specific implementation of a class.</li> <li>Usage of Data Members and Methods: To access the data members and methods of a class, you need to create an object.</li> <li>Physical Representation: While a class is a conceptual framework (logical), an object is the actual entity created from the class (physical).</li> </ul> <p>Example:</p> <pre><code>int main() {\n    Car myCar;\n    myCar.brand = \"Toyota\";\n    myCar.model = \"Corolla\";\n    myCar.year = 2020;\n    myCar.displayInfo();\n    return 0;\n}\n</code></pre> <p>Class vs. Object: Think of the class as a recipe (logical), and the object as the actual dish made from the recipe (physical).</p>","tags":["OOPS","theory"]},{"location":"oops/oops/#access-specifiers","title":"Access Specifiers","text":"<ul> <li>public: Members are accessible from outside the class.</li> <li>private: Members are accessible only within the class. They cannot be accessed directly from outside the class.</li> <li>protected: Members are accessible within the class and by derived classes (inheritance).</li> </ul> <pre><code>class Car {\nprivate:\n    string brand;\n    string model;\n    int year;\npublic:\n    void setDetails(string b, string m, int y) {\n        brand = b;\n        model = m;\n        year = y;\n    }\n    void displayInfo() {\n        cout &lt;&lt; \"Brand: \" &lt;&lt; brand &lt;&lt; \", Model: \" &lt;&lt; model &lt;&lt; \", Year: \" &lt;&lt; year &lt;&lt; endl;\n    }\n};\n\nint main() {\n    Car myCar;\n    // myCar.brand = \"Toyota\"; // Error: 'brand' is private\n    // myCar.model = \"Corolla\"; // Error: 'model' is private\n    // myCar.year = 2020; // Error: 'year' is private\n    myCar.setDetails(\"Toyota\", \"Corolla\", 2020); // Accessible\n    myCar.displayInfo(); // Accessible\n    return 0;\n}\n</code></pre>","tags":["OOPS","theory"]},{"location":"oops/oops/#main-features-of-oop","title":"Main Features of OOP","text":"<ul> <li>Encapsulation</li> <li>Data Abstraction</li> <li>Polymorphism</li> <li>Inheritance</li> </ul>","tags":["OOPS","theory"]},{"location":"oops/oops/#encapsulation","title":"Encapsulation","text":"<ul> <li>Definition: Encapsulation is the binding of data and member functions into a single unit such that sensitive data is hidden from the users.</li> <li>Data hiding: Restricts access to the members of an object, i.e., private and protected members in C++.</li> <li>Bundling of data and methods together: Data members and member methods are wrapped into a single unit known as a class.</li> </ul>","tags":["OOPS","theory"]},{"location":"oops/oops/#abstraction","title":"Abstraction","text":"<ul> <li>Definition: Abstraction is showing only the necessary information and hiding the other irrelevant information from the user, i.e., hiding the implementation details.</li> <li>Real-life example: A man driving a car. The driver knows how to drive but doesn't need to know the internal workings of the engine.</li> </ul>","tags":["OOPS","theory"]},{"location":"oops/oops/#polymorphism","title":"Polymorphism","text":"<ul> <li>Definition: Polymorphism means having many forms. It is the ability of a message to be displayed in more than one form.</li> <li>Example: A man can be a father, a husband, and an employee, exhibiting different behaviors in different instances.</li> </ul> <p>Types of Polymorphism:</p> <ul> <li>Compile Time (Static Binding): Binding of function to object is at compile time. Inheritance is not involved.</li> <li>Run Time (Dynamic Binding): Binding of function to object is at run time. Inheritance is involved.</li> </ul> <p></p>","tags":["OOPS","theory"]},{"location":"oops/oops/#compile-time-polymorphism-function-overloading","title":"Compile Time Polymorphism (Function Overloading)","text":"","tags":["OOPS","theory"]},{"location":"oops/oops/#run-time-polymorphism-inheritance-and-virtual-functions","title":"Run Time Polymorphism (Inheritance and Virtual Functions)","text":"","tags":["OOPS","theory"]},{"location":"oops/oops/#function-overloading","title":"Function Overloading","text":"<ul> <li>Definition: Function overloading is defining multiple functions with the same name in the same class but with different parameter lists (number of arguments, type of arguments, order of arguments).</li> </ul> <p>How Function Overloading Works:</p> <ul> <li>Exact Match: If a function call exactly matches one of the overloaded functions (name and parameters), that function is called.</li> <li>Promotion: If an exact match is not found:</li> <li>char, unsigned char, and short are promoted to int.</li> <li>float is promoted to double.</li> <li>Standard Conversion: If no match is found, C++ tries to find a match through standard type conversion.</li> <li>Error: If no suitable match is found, the compiler throws an error.</li> </ul>","tags":["OOPS","theory"]},{"location":"oops/oops/#constructors","title":"Constructors","text":"","tags":["OOPS","theory"]},{"location":"oops/oops/#what-is-a-constructor","title":"What is a Constructor?","text":"<p>A constructor is a special type of member function in a class that initializes objects of that class. It is automatically called when an object of the class is created. The primary purpose of a constructor is to initialize data members of the class to appropriate values.</p> <p>Key Characteristics of Constructors:</p> <ul> <li>Same Name as the Class: A constructor has the same name as the class in which it resides.</li> <li>No Return Type: Constructors do not have a return type, not even void.</li> <li>Automatically Called: Constructors are called automatically when an object is created.</li> <li>Can Be Overloaded: Multiple constructors can be defined in a class with different parameter lists (constructor overloading).</li> <li>In public</li> </ul> <p>Types of Constructors:</p> <ul> <li>Default Constructor: A constructor that takes no arguments.</li> <li>Parameterized Constructor: A constructor that takes one or more arguments.</li> <li>Copy Constructor: A constructor that initializes an object using another object of the same class.</li> </ul> <p></p> <p></p> <p></p>","tags":["OOPS","theory"]},{"location":"oops/oops/#constructor-overloading","title":"Constructor Overloading","text":"<ul> <li>Definition: Constructor overloading is a form of compile-time polymorphism where multiple constructors are defined in the same class with different parameter lists (number of arguments, type of arguments, order of arguments).</li> </ul> <p>Example:</p>","tags":["OOPS","theory"]},{"location":"oops/oops/#operator-overloading","title":"Operator Overloading","text":"<ul> <li>Definition: Operator overloading allows giving a special meaning to an existing operator without changing its actual meaning. It's mainly used for user-defined data types (e.g., adding two class objects).</li> </ul> <p>Notes:</p> <ul> <li>Some operators cannot be overloaded: sizeof, ::, ., ?:.</li> <li>:: scope resolution</li> <li>. member selection</li> <li>.* member selection through pointer to function</li> <li>?: ternary operator</li> <li>Syntax: RETURN_TYPE operator OPERATOR_SYMBOL (ARGUMENT)</li> </ul> <p>Points to Remember:</p> <ul> <li>Unary Operator: No need to pass an argument.</li> <li>Binary Operator: Need to pass one argument.</li> <li>Destructor: Cannot be overloaded.</li> <li>Friend Function: Can be used to overload operators for non-member functions.</li> </ul> <p></p> <p></p>","tags":["OOPS","theory"]},{"location":"oops/oops/#binary-operator-overloading","title":"Binary Operator Overloading","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Complex {\nprivate:\n    float real;\n    float imag;\npublic:\n    // Constructor to initialize real and imaginary parts\n    Complex(float r = 0, float i = 0) : real(r), imag(i) {}\n\n    // Overloading the binary + operator\n    Complex operator+(const Complex &amp;c) {\n        // Create a temporary Complex object to hold the result\n        Complex temp;\n        temp.real = real + c.real; // Add the real parts\n        temp.imag = imag + c.imag; // Add the imaginary parts\n        return temp; // Return the result\n    }\n\n    // Function to display the complex number\n    void display() const {\n        cout &lt;&lt; \"(\" &lt;&lt; real &lt;&lt; \" + \" &lt;&lt; imag &lt;&lt; \"i)\" &lt;&lt; endl;\n    }\n};\n\nint main() {\n    // Create two Complex objects\n    Complex c1(3.0, 2.0);\n    Complex c2(1.0, 7.0);\n\n    // Add the two Complex objects using the overloaded + operator\n    Complex c3 = c1 + c2;\n\n    // Display the result\n    c3.display(); // Output: (4 + 9i)\n    return 0;\n}\n</code></pre>","tags":["OOPS","theory"]},{"location":"oops/oops/#friend-operator-overloading","title":"Friend Operator Overloading","text":"<p>Friend functions are functions that are not members of a class but have access to its private and protected members. This is useful for operator overloading, especially when you want to overload an operator that interacts with two different classes or when the operator needs to access private data members directly.</p> <p>Example: Overloading the + Operator with a Friend Function</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Complex {\nprivate:\n    float real;\n    float imag;\npublic:\n    // Constructor to initialize real and imaginary parts\n    Complex(float r = 0, float i = 0) : real(r), imag(i) {}\n\n    // Friend function to overload the binary + operator\n    friend Complex operator+(const Complex &amp;c1, const Complex &amp;c2);\n\n    // Function to display the complex number\n    void display() const {\n        cout &lt;&lt; \"(\" &lt;&lt; real &lt;&lt; \" + \" &lt;&lt; imag &lt;&lt; \"i)\" &lt;&lt; endl;\n    }\n};\n\n// Definition of the friend function to overload the + operator\nComplex operator+(const Complex &amp;c1, const Complex &amp;c2) {\n    // Create a temporary Complex object to hold the result\n    Complex temp;\n    temp.real = c1.real + c2.real; // Add the real parts\n    temp.imag = c1.imag + c2.imag; // Add the imaginary parts\n    return temp; // Return the result\n}\n\nint main() {\n    // Create two Complex objects\n    Complex c1(3.0, 2.0);\n    Complex c2(1.0, 7.0);\n\n    // Add the two Complex objects using the overloaded + operator\n    Complex c3 = c1 + c2;\n\n    // Display the result\n    c3.display(); // Output: (4 + 9i)\n    return 0;\n}\n</code></pre>","tags":["OOPS","theory"]},{"location":"oops/oops/#virtual-functions","title":"Virtual Functions","text":"","tags":["OOPS","theory"]},{"location":"oops/oops/#what-is-a-virtual-function","title":"What is a Virtual Function?","text":"<p>A virtual function is a member function declared in the base class using the keyword virtual and can be overridden in a derived class. The purpose of a virtual function is to achieve runtime polymorphism.</p> <ul> <li>Declaration and Overriding:</li> <li>Base Class: Declared using the virtual keyword.</li> <li>Derived Class: Can be overridden (redefined).</li> <li>Execution:</li> <li>If the derived class does not override the virtual function, the base class version is executed.</li> <li>Virtual Destructor: A class can have a virtual destructor but not a virtual constructor.</li> <li>Usage:</li> <li>To achieve runtime polymorphism, a base class pointer/reference is used, which can hold the address of a derived class object.</li> <li>The virtual keyword ensures the function call is bound at runtime based on the actual object type.</li> <li>Real-life Example:</li> <li>Consider a traffic signal scenario where vehicles are a base class with a virtual function move().</li> <li>Derived classes like Car, Bicycle, and Bus override the move() function.</li> <li>When various vehicles need to move, the overridden move() function is called based on the actual vehicle.</li> </ul> <p></p>","tags":["OOPS","theory"]},{"location":"oops/oops/#pure-virtual-functions-and-abstract-classes","title":"Pure Virtual Functions and Abstract Classes","text":"<p>Pure Virtual Function</p> <p>A pure virtual function is a function that has no implementation in the base class and must be overridden in any derived class. It is declared by assigning 0 in its declaration.</p> <p>Abstract Class</p> <p>An abstract class is a class that cannot provide implementations for all its functions. It contains at least one pure virtual function. You cannot create objects of an abstract class.</p> <p>Key Points:</p> <ul> <li>Definition:</li> <li>Abstract Class: A class with at least one pure virtual function.</li> <li>Pure Virtual Function: Declared by assigning 0 in the declaration, e.g., virtual void move() = 0;.</li> <li>Purpose:</li> <li>Abstract classes provide a base for other classes to derive from, ensuring certain functions are implemented in derived classes.</li> <li>Instantiation:</li> <li>You cannot create objects of abstract classes directly.</li> <li>Abstract classes can have pointers and references to abstract class types.</li> <li>Constructors and Destructors:</li> <li>Abstract classes can have constructors and destructors.</li> <li>The destructor of an abstract class is usually declared virtual to ensure proper cleanup of derived class objects.</li> <li>Real-life Example:</li> <li>Consider an Animal class that has a pure virtual function move(). Different animals (derived classes) like Dog, Bird, and Fish will implement the move() function in their own way.</li> </ul> <p></p> <p></p> <p>Explanation:</p> <ul> <li>Animal Class:</li> <li>Declares a pure virtual function move(), making it an abstract class.</li> <li>The destructor is virtual to ensure proper cleanup.</li> <li>Dog Class:</li> <li>Inherits from Animal and overrides the move() function.</li> <li>Bird Class:</li> <li>Inherits from Animal and overrides the move() function.</li> <li>Main Function:</li> <li>Demonstrates runtime polymorphism using a base class pointer (animal) to call the overridden move() function in derived classes (Dog and Bird).</li> </ul> <p>Summary</p> <ul> <li>Abstract Class: Cannot be instantiated and contains at least one pure virtual function.</li> <li>Pure Virtual Function: Must be overridden in any derived class.</li> <li>Runtime Polymorphism: Achieved by using base class pointers or references to call overridden functions in derived classes.</li> <li>Virtual Destructor: Ensures proper cleanup of derived class objects when deleted through a base class pointer.</li> </ul>","tags":["OOPS","theory"]},{"location":"oops/oops/#destructors","title":"Destructors","text":"","tags":["OOPS","theory"]},{"location":"oops/oops/#understanding-destructors","title":"Understanding Destructors","text":"<p>A destructor is a special member function of a class that is executed when an object of that class is destroyed. It is used to clean up resources that the object may have acquired during its lifetime. This can include deallocating memory, closing file handles, or releasing other resources.</p> <p>Key Points About Destructors:</p> <ul> <li>Name:</li> <li>A destructor has the same name as the class, preceded by a tilde (~).</li> <li>Example: For a class named MyClass, the destructor is ~MyClass().</li> <li>No Parameters:</li> <li>Destructors do not take any parameters.</li> <li>You cannot overload a destructor.</li> <li>No Return Type:</li> <li>Destructors do not have a return type, not even void.</li> <li>Automatic Call:</li> <li>The destructor is called automatically when an object goes out of scope or is explicitly deleted.</li> <li>Single Destructor per Class:</li> <li>Each class can have only one destructor.</li> <li>Inheritance:</li> <li>In the context of inheritance, destructors in the base and derived classes are called in reverse order of their construction.</li> </ul>","tags":["OOPS","theory"]},{"location":"oops/oops/#virtual-destructors","title":"Virtual Destructors","text":"<p>A virtual destructor ensures that the destructor of the derived class is called when a base class pointer pointing to a derived class object is deleted. This is crucial for proper resource cleanup and avoiding memory leaks.</p> <p>Why Virtual Destructors Are Important</p> <p>When you delete a derived class object through a base class pointer, if the base class destructor is not virtual, only the base class destructor is called. This can lead to incomplete destruction of the derived class object and potential resource leaks.</p> <p></p> <p>Output:</p> <pre><code>Base Destructor called\n</code></pre> <p>In this case, the Derived class destructor is not called because the Base class destructor is not virtual. This can cause resource leaks if the Derived class allocates resources that need to be explicitly released in its destructor.</p> <p>Example With Virtual Destructor</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Base {\npublic:\n    virtual ~Base() { // Virtual destructor\n        cout &lt;&lt; \"Base Destructor called\" &lt;&lt; endl;\n    }\n};\n\nclass Derived : public Base {\npublic:\n    ~Derived() {\n        cout &lt;&lt; \"Derived Destructor called\" &lt;&lt; endl;\n    }\n};\n\nint main() {\n    Base* b = new Derived();\n    delete b; // Both Derived and Base Destructors are called\n    return 0;\n}\n</code></pre> <p>Output:</p> <pre><code>Derived Destructor called\nBase Destructor called\n</code></pre> <p>With the virtual destructor in place, both the Derived class destructor and the Base class destructor are called, ensuring proper cleanup of the derived class object.</p> <p>How It Works:</p> <ul> <li>Base Class with Virtual Destructor:</li> <li>The Base class declares a virtual destructor: virtual ~Base().</li> <li>This tells the compiler to use runtime polymorphism for the destructor, ensuring the correct destructor is called for the actual object type.</li> <li>Derived Class Destructor:</li> <li>The Derived class defines its own destructor: ~Derived().</li> <li>When the derived class object is deleted through a base class pointer, the derived class destructor is called first, followed by the base class destructor.</li> </ul> <p>Key Points:</p> <ul> <li>Virtual Destructors:</li> <li>Ensure that the destructors of derived classes are called, allowing for complete and proper cleanup.</li> <li>Use the virtual keyword to indicate that the destructor should use runtime polymorphism.</li> <li>Resource Management:</li> <li>Prevents resource leaks by ensuring derived class resources are released properly.</li> <li>Important for classes that manage dynamic memory or other resources that require explicit release.</li> <li>Polymorphism:</li> <li>Virtual destructors are part of the mechanism that allows polymorphic behavior in C++.</li> <li>Necessary for classes intended to be used polymorphically through base class pointers or references.</li> </ul> <p>Summary</p> <ul> <li>Without Virtual Destructor: Only the base class destructor is called when deleting a derived class object through a base class pointer, potentially leading to resource leaks.</li> <li>With Virtual Destructor: Both the derived class and base class destructors are called, ensuring complete and proper cleanup of the object.</li> <li>Usage: Always declare a virtual destructor in a base class if it is intended to be inherited by other classes and used polymorphically.</li> </ul> <p>Note: If a base class pointer holds the address of a derived class and we delete the base class pointer, only the base class destructor is called unless the base class destructor is virtual.</p>","tags":["OOPS","theory"]},{"location":"oops/oops/#inheritance","title":"Inheritance","text":"","tags":["OOPS","theory"]},{"location":"oops/oops/#overview-of-inheritance","title":"Overview of Inheritance","text":"<p>Inheritance is a key feature of Object-Oriented Programming (OOP) that allows a new class (derived class) to inherit properties and behaviors (data members and member functions) from an existing class (base class). It promotes code reusability and establishes a natural hierarchy between classes.</p> <p>Key Concepts:</p> <ul> <li>Base Class (Parent Class): The class whose properties and methods are inherited by another class.</li> <li>Derived Class (Child Class): The class that inherits from the base class.</li> </ul> <p>Why Use Inheritance?</p> <ul> <li>Code Reusability: Inherits properties and methods from the base class, reducing code duplication.</li> <li>Logical Hierarchy: Establishes a logical hierarchy between classes, making the code easier to understand and maintain.</li> <li>Extensibility: Allows the creation of new functionalities based on existing code.</li> </ul>","tags":["OOPS","theory"]},{"location":"oops/oops/#types-of-inheritance","title":"Types of Inheritance","text":"<ul> <li>Single Inheritance: A derived class inherits from a single base class.</li> <li>Example: Vehicle -&gt; Car</li> </ul> <pre><code>class Vehicle {\n    // Base class code\n};\n\nclass Car : public Vehicle {\n    // Derived class code\n};\n</code></pre> <ul> <li>Multiple Inheritance: A derived class inherits from more than one base class.</li> <li>Example: Father -&gt; Son; Mother -&gt; Son</li> </ul> <pre><code>class Father {\n    // Base class code\n};\n\nclass Mother {\n    // Base class code\n};\n\nclass Son : public Father, public Mother {\n    // Derived class code\n};\n</code></pre> <ul> <li>Multilevel Inheritance: A derived class inherits from another derived class.</li> <li>Example: Animal -&gt; Cat -&gt; RussianBlue</li> </ul> <pre><code>class Animal {\n    // Base class code\n};\n\nclass Cat : public Animal {\n    // Derived class code\n};\n\nclass RussianBlue : public Cat {\n    // Derived class code\n};\n</code></pre> <ul> <li>Hierarchical Inheritance: Multiple derived classes inherit from a single base class.</li> <li>Example: Animal -&gt; Cat; Animal -&gt; Dog</li> </ul> <pre><code>class Animal {\n    // Base class code\n};\n\nclass Cat : public Animal {\n    // Derived class code\n};\n\nclass Dog : public Animal {\n    // Derived class code\n};\n</code></pre> <ul> <li>Hybrid Inheritance: A combination of two or more types of inheritance.</li> <li>Example: A complex inheritance pattern involving multiple and hierarchical inheritance.</li> </ul> <pre><code>class Human {\n    // Base class code\n};\n\nclass Boy : public Human {\n    // Derived class code\n};\n\nclass Girl : public Human {\n    // Derived class code\n};\n\nclass Male : public Boy {\n    // Derived class code\n};\n\nclass Female : public Girl {\n    // Derived class code\n};\n</code></pre>","tags":["OOPS","theory"]},{"location":"oops/oops/#constructors-in-inheritance","title":"Constructors in Inheritance","text":"<p>Constructors in derived classes can call constructors in base classes. This is especially important for parameterized constructors.</p> <ul> <li>Default Constructor: Automatically called if no other constructor is specified.</li> <li>Parameterized Constructor: Must explicitly specify the base class's parameterized constructor in the initialization list.</li> </ul> <p></p>","tags":["OOPS","theory"]},{"location":"oops/oops/#destructors-in-inheritance","title":"Destructors in Inheritance","text":"<p>Destructors in derived classes are called in the reverse order of the constructors. The destructor of the derived class is called first, followed by the destructor of the base class.</p> <p></p> <p>Output:</p> <pre><code>Derived Destructor called\nBase Destructor called\n</code></pre>","tags":["OOPS","theory"]},{"location":"oops/oops/#accessing-base-class-members","title":"Accessing Base Class Members","text":"<ul> <li>Inheritance: The derived class inherits public and protected members from the base class. Private members are not accessible directly but can be accessed through public or protected member functions.</li> <li>Friend Class: A derived class can access private members of a base class if the base class declares the derived class as a friend.</li> </ul> <p>Summary</p> <ul> <li>Inheritance: Enables creating new classes from existing classes, promoting code reuse and logical hierarchy.</li> <li>Types: Includes single, multiple, multilevel, hierarchical, and hybrid inheritance.</li> <li>Constructors: Parameterized constructors of base classes must be explicitly called in derived classes.</li> <li>Destructors: Called in the reverse order of construction to ensure proper cleanup.</li> <li>Access: Derived classes can access public and protected members of base classes, with private members accessible through friend classes or member functions.</li> </ul>","tags":["OOPS","theory"]},{"location":"oops/oops/#friend-functions-and-classes","title":"Friend Functions and Classes","text":"","tags":["OOPS","theory"]},{"location":"oops/oops/#friend-function","title":"Friend Function","text":"<p>A friend function is a function that is not a member of a class but can access the private and protected members of the class. It acts as a bridge between two classes by accessing their private data.</p> <p>Key Points:</p> <ul> <li>Not a Member Function:</li> <li>It is not a member of any class.</li> <li>Declared inside the class but defined outside the class.</li> <li>Access:</li> <li>Can access private and protected members of the class where it is declared as a friend.</li> <li>Declaration and Definition:</li> <li>Declared inside the class using the friend keyword.</li> <li>Defined outside the class.</li> <li>Call:</li> <li>Called like a normal function, not using the object and dot operator.</li> </ul> <p></p>","tags":["OOPS","theory"]},{"location":"oops/oops/#friend-class","title":"Friend Class","text":"<p>A friend class is a class that is declared as a friend of another class, allowing it to access private and protected members of the class where it is declared as a friend.</p> <p>Key Points:</p> <ul> <li>Access:</li> <li>Can access private and protected members of the class where it is declared as a friend.</li> <li>Declaration:</li> <li>Declared inside the class using the friend keyword.</li> <li>Scope:</li> <li>A friend class can be declared in public, protected, or private sections of the class.</li> </ul> <p></p>","tags":["OOPS","theory"]},{"location":"oops/oops/#constructor-chaining","title":"Constructor Chaining","text":"<p>Definition:</p> <p>Constructor chaining is a technique in object-oriented programming where one constructor calls another constructor within the same class. It helps reduce code duplication and make the program simpler.</p> <p></p> <p>Explanation:</p> <ul> <li>The Box class has three constructors.</li> <li>The default constructor initializes the dimensions to zero.</li> <li>The parameterized constructor initializes the dimensions to the given values.</li> <li>The constructor with one parameter calls the parameterized constructor with the same value for all dimensions, demonstrating constructor chaining.</li> </ul>","tags":["OOPS","theory"]},{"location":"oops/oops/#static-keyword","title":"Static Keyword","text":"","tags":["OOPS","theory"]},{"location":"oops/oops/#static-variables","title":"Static Variables","text":"<p>Inside Function:</p> <ul> <li>Lifetime: The space for a static variable inside a function is allocated once, and it retains its value between function calls.</li> </ul> <p></p> <p>Inside Class:</p> <ul> <li>Shared by all objects: Only one copy of the static variable is created for all objects of the class.</li> <li>Initialization: Automatically initialized to 0.</li> <li>Declaration: Inside the class.</li> <li>Definition: Outside the class.</li> </ul> <p></p>","tags":["OOPS","theory"]},{"location":"oops/oops/#static-members-of-class","title":"Static Members of Class","text":"<p>Static Member Function:</p> <ul> <li>Can only access static variables.</li> <li>Called using the class name or an object.</li> </ul> <p></p> <p>Static Data Members:</p> <ul> <li>Static data members are shared among all objects of a class. They are not tied to any particular object.</li> <li>Non-static data members are unique to each object of the class.</li> </ul> <p>Static Member Functions:</p> <ul> <li>Static member functions can only access static data members because they are not associated with any object of the class.</li> <li>Non-static member functions can access both static and non-static data members because they operate on an object of the class and have access to the this pointer.</li> </ul> <p>Example:</p> <p></p> <p></p>","tags":["OOPS","theory"]},{"location":"oops/oops/#constant-variables-and-functions","title":"Constant Variables and Functions","text":"","tags":["OOPS","theory"]},{"location":"oops/oops/#constant-variable","title":"Constant Variable","text":"<p>Definition:</p> <p>A constant variable is a variable whose value cannot be changed after it has been initialized. In C++, the const keyword is used to define constant variables.</p> <p>Key Points:</p> <ul> <li>Fixed value: Once assigned, the value of a constant variable cannot be altered.</li> <li>Initialization: Must be initialized at the time of declaration.</li> <li>Usage in C++: Constant data members should be initialized using a constructor initializer list.</li> </ul> <p></p>","tags":["OOPS","theory"]},{"location":"oops/oops/#constant-member-function","title":"Constant Member Function","text":"<p>Definition:</p> <p>A constant member function is a member function that does not modify the state of the object. It can be called on constant objects.</p> <p>Key Points:</p> <ul> <li>Const objects: An object declared as const cannot be modified.</li> <li>Const member function: A member function that guarantees not to alter the object's data members.</li> <li>Syntax: Declared by adding const keyword after the function declaration.</li> </ul> <p></p>","tags":["OOPS","theory"]},{"location":"oops/oops/#the-this-pointer","title":"The 'this' Pointer","text":"<p>Definition:</p> <p>The this pointer in C++ is a special pointer that is implicitly passed to all non-static member functions of a class. It points to the object for which the member function is called.</p> <p>Key Points:</p> <ul> <li>Current Object Address: this is used to retrieve the address of the current object, given in hexadecimal format.</li> <li>Distinguishing Data Members: It helps to distinguish between class data members and local variables when both have the same name.</li> </ul> <p></p> <p>Explanation:</p> <ul> <li>this-&gt;x refers to the data member x of the current object.</li> <li>Without this, x = x; would not distinguish between the parameter and the data member, leading to ambiguity.</li> </ul>","tags":["OOPS","theory"]},{"location":"oops/oops/#virtual-inheritance-diamond-problem","title":"Virtual Inheritance (Diamond Problem)","text":"<p>Definition:</p> <p>The diamond problem occurs in multiple inheritance when two superclasses of a class have a common base class. This can lead to ambiguity and duplication of inherited members.</p> <p>Key Points:</p> <ul> <li>Superclass: A class whose properties are inherited by a subclass.</li> <li>Diamond Shape: The inheritance structure forms a diamond shape.</li> <li>Multiple Copies: Without virtual inheritance, the subclass gets two copies of the common base class attributes.</li> </ul> <p></p> <p>Explanation:</p> <ul> <li>Virtual Inheritance: The virtual keyword ensures that the Person class's attributes are shared and not duplicated in the Intern class, avoiding ambiguity.</li> </ul>","tags":["OOPS","theory"]},{"location":"oops/oops/#structure-vs-class","title":"Structure vs. Class","text":"<p>Structures:</p> <ul> <li>Default Access Specifier: Public.</li> <li>Inheritance: Limited support (typically not used for inheritance).</li> <li>Data Encapsulation: Primarily used for data grouping.</li> <li>Usage: Generally used for passive objects with public data members.</li> </ul> <p>Classes:</p> <ul> <li>Default Access Specifier: Private.</li> <li>Inheritance: Full support, used extensively.</li> <li>Data Encapsulation: Supports data hiding and encapsulation.</li> <li>Usage: Used for creating active objects with both data members and member functions.</li> </ul>","tags":["OOPS","theory"]},{"location":"oops/oops/#reference-vs-pointer","title":"Reference vs. Pointer","text":"<p>References:</p> <ul> <li>Syntax: Declared using &amp;.</li> <li>Nullability: Cannot be null.</li> <li>Reassignment: Cannot be reassigned to reference another object after initialization.</li> <li>Usage: Safer and easier to use, preferred when possible.</li> </ul> <p>Pointers:</p> <ul> <li>Syntax: Declared using *.</li> <li>Nullability: Can be null.</li> <li>Reassignment: Can be reassigned to point to different objects.</li> <li>Usage: More powerful, allows for dynamic memory management.</li> </ul>","tags":["OOPS","theory"]},{"location":"oops/oops/#new-vs-malloc","title":"new vs. malloc","text":"<p>new:</p> <ul> <li>Type Safety: Returns the correct type.</li> <li>Initialization: Calls constructors.</li> <li>Syntax: Operator.</li> <li>Exception Handling: Throws an exception if memory allocation fails.</li> </ul> <p>malloc:</p> <ul> <li>Type Safety: Returns void* (requires casting).</li> <li>Initialization: Does not call constructors.</li> <li>Syntax: Function.</li> <li>Exception Handling: Returns NULL if memory allocation fails.</li> </ul>","tags":["OOPS","theory"]},{"location":"oops/oops/#scope-resolution-operator","title":"Scope Resolution Operator","text":"<p>Definition:</p> <p>The scope resolution operator (::) is used to define the scope of a function or variable, specifically when the same name exists in different scopes.</p> <p>Key Points:</p> <ul> <li>Global Scope: Access global variables when there's a local variable with the same name.</li> <li>Class Scope: Define member functions outside the class definition.</li> <li>Namespace Scope: Access elements of a namespace.</li> </ul> <p></p>","tags":["OOPS","theory"]},{"location":"oops/oops/#interfaces","title":"Interfaces","text":"<p>Definition:</p> <p>An interface is a class with only pure virtual functions. It defines a contract that derived classes must fulfill.</p> <p>Key Points:</p> <ul> <li>Pure Virtual Functions: Functions declared by assigning 0 in the declaration.</li> <li>No Implementation: Derived classes must provide implementations for the pure virtual functions.</li> <li>Abstract Classes: Interfaces are abstract classes.</li> </ul> <p></p> <p>Explanation:</p> <ul> <li>Pure Virtual Function: show() is declared as a pure virtual function in the Interface class.</li> <li>Derived Class: Implementation class provides the implementation for the show() function.</li> </ul>","tags":["OOPS","theory"]},{"location":"os/","title":"Operating System Concepts","text":"<p>Author: Abhinav P Pradeep </p>"},{"location":"os/#what-is-an-operating-system-os","title":"What is an Operating System (OS)?","text":"<p>Definition: An Operating System is system software that acts as an interface between the user and the hardware.</p> <p>Think of OS as: A translator helping humans (users) talk to machines (hardware).</p> <p>Hardware Examples: In a computer: - CPU (Central Processing Unit) \u2013 The brain - Input Devices \u2013 Keyboard, Mouse, Scanner - Output Devices \u2013 Printer, Monitor - Main Memory \u2013 RAM - Secondary Storage \u2013 Hard Disk (HDD/SSD)</p> <p>You don\u2019t interact with hardware directly. The OS handles this interaction on your behalf.</p>"},{"location":"os/#why-do-we-need-an-os","title":"Why Do We Need an OS?","text":"<p>Without an OS: - You\u2019d need to write separate programs to interact with each hardware device (printer, CPU, etc.). - No resource control: One user may lock a device forever. - Managing hardware manually is inefficient, insecure, and slow.</p> <p>With an OS: - Simplifies tasks (e.g., printing with Ctrl+P) - Ensures resource sharing, security, and efficiency</p>"},{"location":"os/#primary-goals-of-an-os","title":"Primary Goals of an OS","text":"Goal Description Convenience Easy for users to access and manage hardware/software Efficiency (Throughput) Maximize number of tasks done per unit time"},{"location":"os/#real-life-os-examples","title":"Real-Life OS Examples","text":"OS Name Known For Market Share (then) Windows High convenience ~95% earlier, ~82% now Linux High throughput Gaining popularity macOS Security &amp; UX Apple ecosystem"},{"location":"os/#functionalities-of-operating-system","title":"Functionalities of Operating System","text":""},{"location":"os/#resource-management","title":"Resource Management","text":"<p>Manages all hardware resources (CPU, memory, I/O). - Especially important in multi-user environments (e.g., servers). - Example: Task Manager shows CPU &amp; RAM usage \u2014 managed by OS.</p>"},{"location":"os/#process-management","title":"Process Management","text":"<p>OS handles execution of multiple processes simultaneously. - Enables Multitasking / Multiprogramming. - Uses CPU Scheduling Algorithms (like FCFS, Round Robin, etc.). - Converts a program (.exe, .c) into a process for execution.</p>"},{"location":"os/#storage-management","title":"Storage Management","text":"<p>Manages secondary storage (HDD/SSD). - Stores user files permanently. - Uses File Systems like:   - Windows: NTFS, FAT32   - Linux: EXT4, NFS, CIFS - Handles:   - File creation/deletion   - Disk space allocation</p>"},{"location":"os/#memory-management","title":"Memory Management","text":"<p>Manages RAM (volatile memory). - RAM is limited. - OS decides:   - How much memory to give to a process   - When to take it back - Handles:   - Swapping   - Allocation &amp; Deallocation   - Segmentation &amp; Paging</p>"},{"location":"os/#security-privacy","title":"Security &amp; Privacy","text":"<p>OS ensures only authorized users and processes access resources. - Example: Login password \u2014 verified using Kerberos (in Windows). - Memory Protection:   - Each process is given its own segment in RAM   - If a process tries to access another\u2019s memory \u2192 Blocked</p>"},{"location":"os/#os-in-action-application-layer","title":"OS in Action: Application Layer","text":"<p>How users interact with OS: - Via Applications: MS Word, Media Player, Browsers - Via Shell/Terminal:   - Windows: Command Prompt   - Linux: Terminal</p> <p>These apps give commands \u2192 OS executes them via System Calls.</p> Action System Call Invoked Open a file open() Print a document write() Read file content read()"},{"location":"os/#summary-table","title":"Summary Table","text":"Functionality Description Resource Management Allocates and deallocates CPU, memory, I/O, etc. Process Management Handles multiple running processes efficiently Storage Management Manages file storage on secondary devices Memory Management Allocates RAM, handles swapping, protects segments Security &amp; Protection Prevents unauthorized access &amp; ensures privacy User Interface GUI or CLI to interact with OS"},{"location":"os/#tips-for-exam-interviews","title":"Tips for Exam &amp; Interviews","text":"<ul> <li>OS acts as Manager, Mediator, and Protector</li> <li>Key terms: Multitasking, System Calls, Throughput, Swapping</li> <li>Examples like Ctrl+P, Command Prompt, Task Manager make answers relatable</li> </ul>"},{"location":"os/#batch-operating-system","title":"Batch Operating System","text":""},{"location":"os/#what-is-a-batch-operating-system","title":"What is a Batch Operating System?","text":"<p>A Batch Operating System is one in which similar jobs are grouped together (in a batch) and executed sequentially without user interaction.</p> <p>Key Idea: - Jobs are prepared offline \u2192 Grouped by an operator \u2192 Fed into the system as a batch</p>"},{"location":"os/#historical-context","title":"Historical Context","text":"<ul> <li>Era: 1960s</li> <li>Used by: Heavy computation organizations (e.g., NASA, ISRO)</li> <li>Input Mediums:</li> <li>Punch cards</li> <li>Paper tape / Magnetic tape</li> <li>User \u2192 Operator \u2192 Computer</li> <li>Users didn\u2019t interact directly with the computer. They handed punch cards to operators.</li> </ul>"},{"location":"os/#working-of-batch-os-step-by-step","title":"Working of Batch OS \u2013 Step by Step","text":"<pre><code>User \u2192 Prepares job offline (punch card)\n      \u2193\nOperator \u2192 Groups jobs into batches (B1, B2, ...)\n      \u2193\nSystem \u2192 Feeds batch into CPU one by one\n      \u2193\nCPU \u2192 Executes one job at a time sequentially\n</code></pre>"},{"location":"os/#major-disadvantages","title":"Major Disadvantages","text":"Problem Why it Happened CPU Idle Time CPU waited during I/O \u2014 no parallel job handling Non-preemptive Execution Next job starts only after the current finishes User has no control or interaction Once submitted, user waits indefinitely Delayed Results Jobs may take days, weeks, or months to complete Heavy Dependence on Operators Job submission &amp; result collection had to go through them"},{"location":"os/#key-characteristics","title":"Key Characteristics","text":"Feature Description Job Grouping Similar jobs grouped into batches Offline Job Submission No real-time input from users No Interactivity No command-line or GUI Sequential Execution Jobs executed one by one Operator Role Acts as a middleman between user &amp; CPU"},{"location":"os/#example-real-life-analogy","title":"Example: Real-life Analogy","text":"<p>Like submitting multiple answer sheets to an examiner. Examiner checks one sheet completely before moving to next. You can't edit or talk once submitted.</p>"},{"location":"os/#evolution-from-operators-to-monitors","title":"Evolution: From Operators to Monitors","text":"<ul> <li>Initial systems used operators to load and manage jobs.</li> <li>Later, monitors were introduced to automate job execution.</li> <li>Allowed direct loading of jobs into the system.</li> <li>Notable early systems:</li> <li>IBM\u2019s FORTRAN Monitor System (FMS)</li> <li>IBSYS on IBM 709X series</li> </ul>"},{"location":"os/#batch-os-vs-modern-os-quick-snapshot","title":"Batch OS vs Modern OS (Quick Snapshot)","text":"Aspect Batch OS (1960s) Modern OS (Today) User Interaction No direct interaction CLI / GUI available Job Execution Sequential (non-preemptive) Concurrent / Multitasking CPU Utilization Low (Idle during I/O) High (Context switching, scheduling) Submission Mode Offline (punch cards) Real-time (Apps, shell, programs) Example Systems IBM FORTRAN Monitor, IBSYS Windows, Linux, macOS"},{"location":"os/#exam-ready-summary","title":"Exam-Ready Summary","text":"Point Detail Full Form Batch Operating System Job Submission Method Offline (Punch Cards, Tapes) Execution Style Sequential, Non-interactive Major Disadvantage CPU Idle Time during I/O Historical Systems FORTRAN Monitor System, IBM IBSYS Usage Time 1960s Interaction Through Operators (no user interaction with CPU)"},{"location":"os/#multiprogramming-vs-multitasking","title":"Multiprogramming vs Multitasking","text":""},{"location":"os/#confusion-clarified","title":"Confusion Clarified","text":"<p>Many students confuse:</p> Term Reality Multiprogramming Older concept (non-preemptive) Multitasking / Time-Sharing Modern OS behavior (preemptive)"},{"location":"os/#multiprogramming-os","title":"Multiprogramming OS","text":"<p>Definition: Multiple programs are kept in RAM, and the CPU executes one at a time (till I/O or end).</p> <ul> <li>Non-preemptive execution.</li> </ul> <p>Analogy: - 10 students have 5 questions each. - CPU (Teacher) goes to Student 1 \u2192 Solves all 5 questions \u2192 Then to Student 2 \u2192 All 5 \u2192 Then Student 3 \u2192 All 5 \u2026 and so on. - If Student 1 asks for calculator (I/O), teacher pauses &amp; helps Student 2 next.</p> <p>How It Works: - Multiple processes in RAM - Only 1 process gets CPU at a time - If process requests I/O, CPU switches to another</p> <p>Goals:</p> Focus Area Description Maximize CPU Utilization Avoid CPU idle when I/O happens Simple Scheduling No forceful switching \u2013 only if needed <p>Limitations: - Slow response time for later processes - No real-time interactivity - Users must wait long for response</p>"},{"location":"os/#multitasking-time-sharing-os","title":"Multitasking (Time-Sharing) OS","text":"<p>Definition: OS gives each process a time slice of CPU (time quantum), and preempts to next if time is up.</p> <ul> <li>Preemptive scheduling</li> </ul> <p>Analogy: - Same 10 students. - CPU decides: I\u2019ll solve only 2 questions per student at a time \u2192 Goes to Student 1 \u2192 Q1, Q2 \u2192 Then Student 2 \u2192 Q1, Q2 \u2192 ... \u2192 Student 10 \u2192 Q1, Q2 \u2192 Then comes back again for Q3, Q4\u2026 - Everyone gets attention early</p> <p>How It Works: - CPU switches rapidly between processes - Uses scheduling algorithms (e.g., Round Robin) - Gives illusion of parallel execution</p> <p>Goals:</p> Focus Area Description Responsiveness Reduce waiting time for users Fairness Every process gets chance to execute Low Latency Quick response to user interactions"},{"location":"os/#multiprogramming-vs-multitasking-quick-comparison","title":"Multiprogramming vs Multitasking \u2013 Quick Comparison","text":"Feature Multiprogramming Multitasking / Time-Sharing Execution Type Non-preemptive Preemptive CPU Allocation Until completion or I/O request For fixed time quantum Main Goal Maximize CPU usage Minimize response time Responsiveness Low High Example Analogy 1 student full work \u2192 then next All students get partial attention Real-World Use Today Rare (historical) Common (used in laptops/phones) Scheduling Algorithms Simple / Static Round Robin, Priority Scheduling CPU Idle Reduced but still possible Almost none"},{"location":"os/#where-are-they-used","title":"Where Are They Used?","text":"OS Type Real Example Multiprogramming Historical mainframes (e.g. IBM 7094) Multitasking Windows, macOS, Linux, Android, iOS"},{"location":"os/#key-exam-points","title":"Key Exam Points","text":"Concept Remember Fork creates new process Uses system call, returns child with PID = 0 Threads share memory Fast, efficient, but blocking is dangerous Context switch speed Thread &gt; Process Independence Process = independent, Thread = interdependent Blocking Blocking one process does NOT block others Blocking one thread blocks the entire process <p>Final Verdict:</p> Use Process When... Use Thread When... You need isolation or security You need speed and shared memory You expect crash resilience You expect high parallelism and low overhead"},{"location":"os/#types-of-operating-systems","title":"Types of Operating Systems","text":""},{"location":"os/#real-time-distributed-clustered-embedded","title":"Real-Time, Distributed, Clustered, Embedded","text":"OS Type Core Idea Typical Place Must-Remember Keywords Real-Time (RTOS) Meet deadlines every time Missile control, Pacemakers, Live stock trading Deadline, Deterministic, Hard vs Soft Distributed Many geographically-spread computers cooperate via a network Google search, Netflix CDN, Blockchain Loose coupling, Location transparency, Fault tolerance Clustered Several machines on one local network act as a single powerful server Supercomputers, High-performance DB clusters Tightly coupled, Load balancing, High availability Embedded OS baked into a device with one dedicated job Washing machine, Router, Car ECU Resource-constrained, Firmware, Fixed function"},{"location":"os/#real-time-operating-system-rtos","title":"Real-Time Operating System (RTOS)","text":"Aspect Hard RTOS Soft RTOS Deadline Must never slip Occasional slip acceptable Example Air-bag controller, Missile guidance Online gaming, Live video stream Scheduling Rate-Monotonic, EDF Hybrid priority + time slicing Failure Impact Catastrophic Degraded QoS <p>Key Line: \u201cCorrect result at the correct time, not just the correct result.\u201d</p>"},{"location":"os/#distributed-operating-system","title":"Distributed Operating System","text":"<ul> <li>\u201cOne system, many sites.\u201d</li> <li>Computers are loosely coupled but behave (to the user) like one virtual machine.</li> <li>Why Use It?:</li> <li>Scalability: Add servers as demand grows.</li> <li>Fault tolerance: If node A dies, node B steps in.</li> <li>Data locality: Serve users from the nearest region (CDN).</li> <li>Hallmarks:</li> <li>Network OS layer handles message passing &amp; transparency.</li> <li>Uses concepts like distributed file systems (DFS) &amp; consensus (Raft, Paxos).</li> </ul>"},{"location":"os/#clustered-operating-system","title":"Clustered Operating System","text":"<ul> <li>\u201cMany PCs, one rack, one purpose.\u201d</li> </ul> Feature Distributed Clustered Distance Often world-wide Same room / rack Coupling Loose Tighter (shared storage / heartbeat) Goal Availability + geo-scaling Raw performance, fail-over Example Google global infra 64-node HPC cluster, Hadoop rack <p>Building Blocks: - Node OS + Cluster middleware (e.g., Kubernetes, Hadoop YARN, Windows Failover Cluster). - Heartbeat monitors node health; load balancer spreads work.</p>"},{"location":"os/#embedded-operating-system","title":"Embedded Operating System","text":"<ul> <li>\u201cSoftware inside stuff.\u201d</li> <li>Signature traits:</li> <li>ROM / Flash storage, tiny RAM (KB\u2013MB).</li> <li>No user install/uninstall; firmware updated only by vendor.</li> <li>Real-time flavoured if timing is critical (e.g., ABS brakes).</li> <li>Micro-kernels &amp; RTOS variants:</li> <li>FreeRTOS, VxWorks, Zephyr, Embedded Linux (BusyBox)</li> </ul>"},{"location":"os/#cheat-sheet-table","title":"Cheat-Sheet Table","text":"Feature \u27a1 Real-Time Distributed Clustered Embedded Primary Goal Timeliness Geo-scalable services High throughput &amp; HA Dedicated device control Coupling \u2013 Loose Tight \u2013 Failure Handling Hard \u2192 system halt Shift work to peers Fail-over node Often watchdog reset User Interaction Often none Via network Via network / API None or minimal UI Key Metric Deadline meet % Availability Speed + uptime Power + cost"},{"location":"os/#system-call","title":"System Call","text":""},{"location":"os/#what-is-a-system-call","title":"What is a System Call?","text":"<p>A System Call is a programmatic interface that allows a user-level program to request services from the Operating System\u2019s kernel, typically for resource access or privileged operations.</p>"},{"location":"os/#why-system-calls","title":"Why System Calls?","text":"<ul> <li>User programs run in User Mode (no direct hardware access).</li> <li>OS Kernel runs in Kernel Mode and controls hardware, memory, files, I/O.</li> <li>To perform tasks like file operations, memory access, process control, or hardware use, user mode must switch to kernel mode using a System Call.</li> </ul> <p>Example:</p> <pre><code>printf(\"Hello World\");\n</code></pre> <ul> <li>printf() is a library function, not a system call.</li> <li>Internally, it uses a write() system call to print on monitor (device).</li> </ul>"},{"location":"os/#mode-transition","title":"Mode Transition","text":"Action Mode Execute user code (e.g., 2+2) User Mode Access file, I/O, hardware Kernel Mode via System Call <p>System Call acts as a bridge between user-level program and kernel.</p>"},{"location":"os/#real-examples","title":"Real Examples","text":"<ul> <li>C / Linux: You can directly use open(), read(), write() system calls.</li> <li>Windows: 600\u2013700 system calls available (e.g., via WinAPI).</li> </ul>"},{"location":"os/#categories-of-system-calls","title":"Categories of System Calls","text":"Category Description Examples File Manipulation Create, read, write, delete, open or close files. open(), read(), write(), close(), unlink() Device Manipulation Interact with I/O devices. ioctl(), read(), write(), lseek() Process Control Create/terminate processes, manage execution. fork(), exec(), exit(), wait(), kill() Information Maintenance Get system or process information. getpid(), getppid(), uname(), time() Communication Inter-Process Communication (IPC). pipe(), shmget(), msgsnd(), connect() Protection &amp; Security Set permissions, access control. chmod(), umask(), setuid()"},{"location":"os/#common-linux-system-calls","title":"Common Linux System Calls","text":"Function System Call Print to screen write() Read keyboard input read() Open file open() Create new process fork() Replace process image exec() Wait for child wait() Get process ID getpid() Change permissions chmod() Set alarms/timers alarm(), sleep()"},{"location":"os/#system-call-flow-behind-the-scenes","title":"System Call Flow (Behind the Scenes)","text":"<pre><code>User Code (e.g., printf) \n   \u2193\nLibrary Function (e.g., stdio.h)\n   \u2193\nSystem Call (e.g., write)\n   \u2193\nKernel Mode \u2014 Performs device-level operation\n</code></pre> <p>Real-Life Analogy: - System Call is like ringing a bell at the manager\u2019s office (kernel) to approve special requests (e.g., print, read file). You (user) can't do it directly.</p>"},{"location":"os/#fork-system-call","title":"Fork System Call","text":""},{"location":"os/#what-is-fork","title":"What is fork()?","text":"<p>fork() is a system call used in UNIX/Linux OS to create a new process. - The new process is called the child process. - The process that calls fork() is the parent process.</p> <p>Child is a clone of the parent: - It has its own Process ID (PID). - It gets a copy of the parent\u2019s code, stack, heap, and data segment. - But both parent and child run independently and concurrently.</p> <p>Syntax (C): <pre><code>pid_t pid = fork();\n</code></pre></p>"},{"location":"os/#return-values-of-fork","title":"Return Values of fork()","text":"Return Value Meaning 0 Returned in the child process &gt; 0 Positive value (PID of child) returned in the parent process -1 Error in creating child (rare, ignore for theory-based questions) <p>Key Concept: - After a single fork(), two processes start running: one parent and one child.</p> <p>Example: <pre><code>main() {\n  fork();\n  printf(\"Hello\\n\");\n}\n</code></pre></p> <p>Output: <pre><code>Hello\nHello\n</code></pre></p> <p>Because both parent and child execute printf().</p>"},{"location":"os/#multiple-fork-calls","title":"Multiple fork() Calls","text":"<p>Number of total processes created: - If there are n fork() calls:   - Total number of processes = 2^n   - Number of child processes = 2^n - 1</p> <p>Example: 2 forks: <pre><code>main() {\n  fork(); // 1st fork\n  fork(); // 2nd fork\n  printf(\"Hello\\n\");\n}\n</code></pre></p> <ul> <li>Total processes = 2^2 = 4</li> <li>Total child processes = 2^2 - 1 = 3</li> <li>Output: Hello printed 4 times</li> </ul> <p>Process Tree:</p> <pre><code>Parent\n\u251c\u2500\u2500 Child1\n\u2502   \u2514\u2500\u2500 Child3\n\u2514\u2500\u2500 Child2\n</code></pre> <p>Example: 3 forks: <pre><code>main() {\n  fork();\n  fork();\n  fork();\n  printf(\"Hello\\n\");\n}\n</code></pre></p> <ul> <li>Total processes = 2^3 = 8</li> <li>Child processes = 2^3 - 1 = 7</li> <li>Output: Hello printed 8 times</li> </ul> <p>Formula: - Total \"Hello\"s = 2^n - Total Child Processes = 2^n - 1</p> <p>Notes: - fork() copies the process context, but both child and parent continue from the same point after the fork() call. - Execution order is not deterministic (depends on scheduler). - In questions, always assume ideal case \u2014 fork always succeeds (ignore -1).</p>"},{"location":"os/#fork-vs-thread-quick-mention","title":"fork vs Thread (Quick Mention)","text":"Feature fork() Thread Process ID New Shared Memory Separate Shared Overhead High Low Use Full new process Lightweight parallel task <p>Example Use Case: - Running different applications \u2014 e.g. browser, text editor (Process) - Performing parallel tasks in same application \u2014 e.g. multiple tabs in a browser (Thread)</p>"},{"location":"os/#process-vs-thread","title":"Process vs Thread","text":"Aspect Process Thread Definition Independent program in execution, heavyweight Lightweight unit of a process, part of a process Creation Via system call like fork() (Kernel-mode involvement) Created by application/program (User-mode, fast) Overhead High \u2014 complete duplicate of code, data, stack, registers Low \u2014 threads share code and data, but each has own stack and registers System Call Yes (e.g. fork(), requires kernel access) Not needed for user-level threads Managed By Operating System Application/User-level thread library (unless kernel-level threads) Memory Each process has separate memory space Threads of a process share memory space Context Switching Slower \u2014 requires saving full PCB, flushing caches Faster \u2014 fewer values to save/restore (registers, stack pointer) Communication (IPC) Needs Inter Process Communication (e.g. pipes, sockets) Easier communication via shared memory Independence Processes are independent \u2014 blocking one doesn't block others Threads are interdependent \u2014 blocking one blocks all in that process Blocking Blocking one process does NOT block others Blocking one thread blocks the entire process Example Use Case Running different applications \u2014 e.g. browser, text editor Performing parallel tasks in same application \u2014 e.g. multiple tabs in a browser Identification Each process has its own PID (Process ID) All threads share same PID, but have Thread IDs (TID) Resource Sharing No (separate memory, stack, etc.) Yes (code, data, files shared) Typical Usage Used when tasks are independent and need resource isolation Used when tasks are similar or related, e.g. multi-client server threads"},{"location":"os/#real-life-analogy","title":"Real-life Analogy","text":"<ul> <li>Process = Human clone \u2192 Complete separate body, brain, identity</li> <li>Thread = Extra arm of same person \u2192 Same brain, same body, just extra workers</li> </ul>"},{"location":"os/#example-scenario","title":"Example Scenario","text":"<p>Print Server: - Using processes \u2192 Each request spawns a full child process = slow and memory intensive. - Using threads \u2192 One server process spawns lightweight threads for each print request = efficient, fast.</p>"},{"location":"os/#key-exam-points_1","title":"Key Exam Points","text":"Concept Remember Fork creates new process Uses system call, returns child with PID = 0 Threads share memory Fast, efficient, but blocking is dangerous Context switch speed Thread &gt; Process Independence Process = independent, Thread = interdependent Blocking Blocking one process does NOT block others Blocking one thread blocks the entire process <p>Final Verdict:</p> Use Process When... Use Thread When... You need isolation or security You need speed and shared memory You expect crash resilience You expect high parallelism and low overhead"},{"location":"os/#threads","title":"Threads","text":"<p>A thread is a lightweight process and forms the basic unit of CPU utilization. A process can perform more than one task at the same time by including multiple threads. - A thread has its own program counter, register set, and stack - A thread shares resources with other threads of the same process the code section, the data section, files and signals.</p> <p>A new thread, or a child process of a given process, can be introduced by using the fork() system call. A process with n fork() system calls generates 2^n - 1 child processes.</p> <p>There are two types of threads: - User threads - Kernel threads</p> <p>Example: Java thread, POSIX threads. Example: Window Solaris.</p>"},{"location":"os/#types-of-threads","title":"Types of Threads","text":""},{"location":"os/#based-on-the-number-of-threads","title":"Based on the Number of Threads","text":"<p>There are two types of threads: (i) Single thread process (ii) Multi thread process</p>"},{"location":"os/#based-on-level","title":"Based on Level","text":"<p>There are two types of threads: (i) User-level threads (ii) Kernel-level threads</p>"},{"location":"os/#process","title":"Process","text":"<p>A process is a program under execution. The value of program counter (PC) indicates the address of the next instruction of the process being executed. Each process is represented by a Process Control Block (PCB).</p> <p>Process States Diagram:</p> <p>[Diagram: New \u2192 Ready \u2192 Running \u2192 Waiting \u2192 Terminated, with transitions]</p>"},{"location":"os/#schedulers","title":"Schedulers","text":"<p>The operating system deploys three kinds of schedulers: - Long-term scheduler: It is responsible for the creation and bringing of new processes into the main memory (New \u2192 Ready state transition). - Medium-term scheduler: The medium-term scheduler selects a process from the ready state to be executed (Ready \u2192 Run state transition). - Short-term scheduler: The short-term scheduler selects a process from the ready state to be executed (Ready \u2192 Run state transition).</p>"},{"location":"os/#dispatchers","title":"Dispatchers","text":"<p>The dispatcher is responsible for loading the job (selected by the short-term scheduler) onto the CPU. It performs context switching. Context switching refers to saving the context of the process which was being executed by the CPU and loading the context of the new process that is being scheduled to be executed by the CPU.</p>"},{"location":"os/ind1/","title":"CPU Scheduling and Process Synchronization","text":"<p>Author: Abhinav P Pradeep </p>"},{"location":"os/ind1/#introduction-to-cpu-scheduling","title":"Introduction to CPU Scheduling","text":"<p>CPU Scheduling is the process by which the Operating System (OS) selects a process from the ready queue and allocates the CPU to it.</p> <ul> <li>In uniprocessor systems, only one process can execute at a time.</li> <li>Other processes remain in the ready queue (in RAM).</li> <li>Scheduling improves:</li> <li>CPU utilization</li> <li>Throughput</li> <li>Turnaround time</li> <li>Waiting time</li> <li>Response time</li> </ul>"},{"location":"os/ind1/#classification-of-scheduling","title":"Classification of Scheduling","text":""},{"location":"os/ind1/#based-on-preemption","title":"Based on Preemption","text":"Type Description Non-Preemptive Once a process starts execution, it runs to completion. No interruption. Preemptive A running process can be interrupted and put back in the ready queue."},{"location":"os/ind1/#key-terms-in-scheduling","title":"Key Terms in Scheduling","text":"Term Description Formula Arrival Time (AT) Time when process enters ready queue \u2013 Burst Time (BT) CPU time required by process \u2013 Completion Time (CT) Time when process finishes execution \u2013 Turnaround Time (TAT) CT - AT TAT = CT - AT Waiting Time (WT) TAT - BT WT = TAT - BT Response Time (RT) First CPU allocation - AT RT = First Start - AT"},{"location":"os/ind1/#non-preemptive-scheduling-algorithms","title":"Non-Preemptive Scheduling Algorithms","text":""},{"location":"os/ind1/#first-come-first-serve-fcfs","title":"First Come First Serve (FCFS)","text":"<ul> <li>Strategy: Process with earliest arrival gets CPU first.</li> <li>Type: Non-preemptive</li> <li>Example: Queue at a ticket counter</li> </ul> <p>Pros: - Simple to implement - Fair (in order of arrival)</p> <p>Cons: - Convoy Effect: Short processes stuck behind long ones - Not optimal for average Waiting Time (WT)/Turnaround Time (TAT)</p>"},{"location":"os/ind1/#shortest-job-first-sjf","title":"Shortest Job First (SJF)","text":"<ul> <li>Strategy: Process with shortest burst time executed first</li> <li>Type: Non-preemptive</li> <li>Optimal: Gives lowest average waiting time</li> <li>Problem: Requires knowledge of burst time in advance</li> </ul> <p>Example: | P1: 8ms | P2: 4ms | P3: 2ms | Execute P3 \u2192 P2 \u2192 P1</p> <p>Pros: - Optimal WT and TAT</p> <p>Cons: - Hard to predict burst time - Starvation of long processes</p>"},{"location":"os/ind1/#priority-scheduling","title":"Priority Scheduling","text":"<ul> <li>Each process assigned a priority</li> <li>Lower number = higher priority</li> <li>Non-preemptive version: Once a process starts, it runs fully</li> <li>Problem: Starvation of lower priority processes</li> <li>Solution: Aging \u2013 Gradually increase priority of waiting processes</li> </ul>"},{"location":"os/ind1/#longest-job-first-ljf","title":"Longest Job First (LJF)","text":"<ul> <li>Reverse of SJF: Process with longest burst time gets CPU</li> <li>Non-preemptive</li> <li>Rarely used due to unfairness to short processes</li> </ul>"},{"location":"os/ind1/#highest-response-ratio-next-hrrn","title":"Highest Response Ratio Next (HRRN)","text":"<ul> <li>Formula:   <pre><code>Response Ratio = (Waiting Time + Burst Time) / Burst Time\n               = 1 + (WT / BT)\n</code></pre></li> <li>The process with the highest ratio gets CPU</li> <li>Solves starvation in SJF</li> </ul>"},{"location":"os/ind1/#preemptive-scheduling-algorithms","title":"Preemptive Scheduling Algorithms","text":""},{"location":"os/ind1/#round-robin-rr","title":"Round Robin (RR)","text":"<ul> <li>Time-sharing system</li> <li>Each process gets CPU for fixed time quantum (q)</li> <li>After time expires \u2192 moved to back of queue</li> </ul> <p>Example: 10 processes, each gets 2s \u2192 fairness improves</p> <p>Pros: - Good responsiveness - Fair to all</p> <p>Cons: - Context switching overhead - Poor for long processes</p>"},{"location":"os/ind1/#shortest-remaining-time-first-srtf","title":"Shortest Remaining Time First (SRTF)","text":"<ul> <li>Preemptive version of SJF</li> <li>At any time, schedule the process with least remaining burst time</li> </ul> <p>Example: If P1 (BT=8ms) is running, and P2 (BT=2ms) arrives \u2192 preempt P1 and run P2.</p> <p>Pros: - Lowest average waiting time</p> <p>Cons: - Starvation - Requires future burst time knowledge</p>"},{"location":"os/ind1/#preemptive-priority-scheduling","title":"Preemptive Priority Scheduling","text":"<ul> <li>Interrupts current process if a higher-priority process arrives</li> <li>Cons:</li> <li>Starvation</li> <li>Use Aging to resolve</li> </ul>"},{"location":"os/ind1/#longest-remaining-time-first-lrtf","title":"Longest Remaining Time First (LRTF)","text":"<ul> <li>Reverse of SRTF</li> <li>Schedule the process with the maximum remaining time</li> <li>Rare in real systems</li> </ul>"},{"location":"os/ind1/#useful-facts-about-scheduling-algorithms","title":"Useful Facts About Scheduling Algorithms","text":"<ol> <li>FCFS can cause long waiting times, especially when the first job takes too much CPU time.</li> <li>Both SJF and Shortest Remaining Time First algorithms may cause starvation, especially when shorter processes keep arriving.</li> <li>If the time quantum for Round Robin scheduling is very large, it behaves the same as FCFS scheduling.</li> <li>SJF is optimal in terms of average waiting time for a given set of processes, but the challenge is predicting the burst time of the next job.</li> </ol>"},{"location":"os/ind1/#problem-solving-checklist","title":"Problem-Solving Checklist","text":"<ol> <li>Draw Gantt Chart</li> <li>Track Arrival and Completion Time</li> <li>Apply formulas:</li> <li>TAT = CT - AT</li> <li>WT = TAT - BT</li> <li>RT = First Start - AT</li> <li>Average the values if needed</li> </ol>"},{"location":"os/ind1/#process-synchronization","title":"Process Synchronization","text":"<p>Process Synchronization is the technique to ensure that multiple processes can execute concurrently without interfering with each other or leading to inconsistent data.</p> <ul> <li>Needed in multiprogramming/parallel systems.</li> <li>Ensures data consistency, deadlock avoidance, and process coordination.</li> </ul>"},{"location":"os/ind1/#serial-vs-parallel-execution","title":"Serial vs Parallel Execution","text":"Execution Type Description Example Serial One process runs at a time. No overlap. ATM: One user at a time Parallel Multiple processes may execute simultaneously. Online banking, IRCTC"},{"location":"os/ind1/#types-of-processes","title":"Types of Processes","text":""},{"location":"os/ind1/#independent-processes","title":"Independent Processes","text":"<ul> <li>No shared data/code/resource</li> <li>No effect on each other</li> <li>Example: SBI and HDFC online transactions</li> </ul>"},{"location":"os/ind1/#cooperative-processes","title":"Cooperative Processes","text":"<ul> <li>Share variables, memory, resources, or code</li> <li>Execution of one affects the other</li> <li>Example: IRCTC bookings, shared printer, shared counter in multithreaded apps</li> </ul>"},{"location":"os/ind1/#why-is-synchronization-needed","title":"Why is Synchronization Needed?","text":"<p>Cooperative processes can lead to problems like: - Race Conditions - Inconsistent Data - Deadlocks</p> <p>Analogy: Guitar strings must be tuned (synchronized) to make music. Otherwise, they create noise.</p>"},{"location":"os/ind1/#critical-section-problem","title":"Critical Section Problem","text":"<ol> <li>Critical Section: The portion of the code in the program where shared variables are accessed and/or updated.</li> <li>Remainder Section: The remaining portion of the program excluding the Critical Section.</li> <li>Race around Condition: The final output of the code depends on the order in which the variables are accessed.</li> </ol>"},{"location":"os/ind1/#race-condition-illustrated","title":"Race Condition \u2013 Illustrated","text":"<p>Scenario: - Two processes: P1 and P2 - Shared Variable: <code>shared = 5</code></p> <p>P1 Code: <pre><code>x = shared;\nx++;\nsleep(1);\nshared = x;\n</code></pre></p> <p>P2 Code: <pre><code>y = shared;\ny--;\nsleep(1);\nshared = y;\n</code></pre></p> <p>Execution Flow with Uni-Processor: - Initially, <code>shared = 5</code> 1. P1 gets CPU:    - <code>x = 5</code>    - <code>x++</code> \u2192 <code>x = 6</code>    - <code>sleep(1)</code> \u2192 context switch to P2 2. P2 executes:    - <code>y = 5</code>    - <code>y--</code> \u2192 <code>y = 4</code>    - <code>sleep(1)</code> \u2192 back to P1 3. P1 resumes:    - <code>shared = x</code> (6) 4. P2 resumes:    - <code>shared = y</code> (4)</p> <p>Result: Final <code>shared = 4</code> (which is WRONG)</p> <p>Expected Output: <code>shared = 5</code> (increment and decrement cancel each other)</p> <p>Root Cause: Shared variable access without synchronization</p> <p>Possible Outcomes:</p> First Process Final Value of shared P1 4 (wrong) P2 6 (wrong) <p>The final value depends on execution order, which is unpredictable. This unpredictability is called a Race Condition.</p>"},{"location":"os/ind1/#solution-synchronization-techniques","title":"Solution: Synchronization Techniques","text":"<p>To avoid race conditions: - Use Mutual Exclusion - Synchronize access to shared resources</p> <p>Techniques: - Locks / Mutexes - Semaphores - Peterson's Solution (software solution) - Monitors (used in Java)</p>"},{"location":"os/ind1/#critical-section","title":"Critical Section","text":""},{"location":"os/ind1/#what-is-a-critical-section","title":"What is a Critical Section?","text":"<p>A critical section is a part of a program where shared resources (e.g., memory, variables, files) are accessed.</p> <ul> <li>Important in concurrent cooperative processes\u2014multiple processes sharing something like memory or a variable.</li> </ul> <p>Example: <pre><code>// Shared variable\nint count = 0;\nvoid increment() {\n    // Critical Section\n    count++;\n}\n</code></pre></p>"},{"location":"os/ind1/#code-division","title":"Code Division","text":"<p>In any concurrent program, the code is divided into:</p> Section Description Critical Section Code accessing shared/common resources. Non-Critical Section Code accessing private/independent resources."},{"location":"os/ind1/#why-critical-sections-need-care","title":"Why Critical Sections Need Care?","text":"<p>If two processes access shared data at the same time, it can cause a Race Condition.</p> <p>Race Condition Example: <pre><code>// P1: count++\ntemp = count;       // read\ntemp = temp + 1;\ncount = temp;       // write\n// P2: count--\ntemp = count;       // read\ntemp = temp - 1;\ncount = temp;       // write\n</code></pre></p> <p>If both execute simultaneously, the final value of <code>count</code> is unpredictable!</p>"},{"location":"os/ind1/#solution-synchronization","title":"Solution: Synchronization","text":"<p>To avoid race conditions: 1. Entry Section: Code that checks if a process can enter the critical section. 2. Exit Section: Code that runs after leaving the critical section. 3. Remainder Section: Non-critical section code.</p> <p>Only one process should enter the critical section at a time, enforced by synchronization mechanisms like Semaphores, Mutexes, etc.</p>"},{"location":"os/ind1/#conditions-for-a-good-synchronization-solution","title":"Conditions for a Good Synchronization Solution","text":"<p>A good solution must follow 4 conditions (2 primary, 2 secondary):</p> # Condition Type Meaning 1 Mutual Exclusion Primary Only one process is allowed inside critical section at a time. 2 Progress Primary If no one is in CS, a process interested should get a chance without being blocked by an idle one. 3 Bounded Waiting Secondary A process should not wait forever to enter CS. There should be a limit on waiting time. 4 No Hardware Assumptions Secondary Solution must be portable, not dependent on system speed, CPU architecture, or OS."},{"location":"os/ind1/#mutual-exclusion-example","title":"Mutual Exclusion (Example)","text":"<p>If P1 is inside the bathroom (CS), P2 must wait outside. Think of a washroom lock: If it's locked, the other person can\u2019t enter.</p>"},{"location":"os/ind1/#progress-example","title":"Progress (Example)","text":"<p>If no one is in the CS, and P1 wants to enter, but P2's code stops it, then progress is violated. No process should stop others unnecessarily if it itself doesn\u2019t want to enter CS.</p>"},{"location":"os/ind1/#bounded-waiting-example","title":"Bounded Waiting (Example)","text":"<ul> <li>P1 entered CS 3 times, P2 is still waiting \u2192 Okay.</li> <li>P1 enters infinite times, P2 never enters \u2192 Starvation, violates bounded waiting.</li> <li>We must ensure that every process gets a chance eventually.</li> </ul>"},{"location":"os/ind1/#no-assumptions-example","title":"No Assumptions (Example)","text":"<ul> <li>Wrong approach: \u201cThis solution works only on 32-bit Linux with 1GHz CPU.\u201d</li> <li>Correct approach: Solution should run on any OS/hardware, i.e., should be universal and portable.</li> </ul>"},{"location":"os/ind1/#real-life-analogy","title":"Real-Life Analogy","text":"Concept Analogy Critical Section Bathroom Entry Section Door Lock Mutual Exclusion Only one person at a time Bounded Wait Everyone gets a turn Progress Don\u2019t block if you\u2019re not interested No Assumptions Any house guest can use the bathroom"},{"location":"os/ind1/#semaphore","title":"Semaphore","text":""},{"location":"os/ind1/#what-is-a-semaphore","title":"What is a Semaphore?","text":"<p>A semaphore is a tool to prevent race conditions in concurrent/cooperative process environments. It ensures synchronization between processes.</p> <p>Defined as: \u201cAn integer variable used in a mutual exclusive manner by various concurrent cooperative processes to achieve synchronization.\u201d</p>"},{"location":"os/ind1/#types-of-semaphores","title":"Types of Semaphores","text":"Type Range / Values Use Case Counting -\u221e to +\u221e Track multiple resources Binary 0 or 1 (like a flag) Acts like a lock mechanism"},{"location":"os/ind1/#structure-process-synchronization","title":"Structure: Process Synchronization","text":"<p>Each process follows this structure: 1. Entry Section \u2013 Code before entering critical section 2. Critical Section \u2013 Shared code or resource 3. Exit Section \u2013 Code after finishing in critical section</p>"},{"location":"os/ind1/#semaphore-operations","title":"Semaphore Operations","text":"Entry Code Exit Code Other Names P() V() Down() Up() Wait() Signal() Post() / Release() <p>All are synonyms: - P = Down = Wait - V = Up = Signal = Post</p>"},{"location":"os/ind1/#how-p-down-wait-works","title":"How P() (Down / Wait) Works","text":"<pre><code>P(S):            // Entry code\nS = S - 1;\nif (S &lt; 0)\n    block the process (add to suspended list);\n</code></pre> <ul> <li>If S \u2265 0 \u2192 process enters</li> <li>If S &lt; 0 \u2192 process is blocked (goes to suspended list or sleep)</li> </ul> <p>Example: - If S = 3 \u2192 3 processes can enter successfully. - After 3 P() ops \u2192 S = 0 - Next P() \u2192 S becomes -1 \u2192 process is blocked</p>"},{"location":"os/ind1/#how-v-up-signal-works","title":"How V() (Up / Signal) Works","text":"<pre><code>V(S):            // Exit code\nS = S + 1;\nif (S \u2264 0)\n    wake up one process from suspended list;\n</code></pre> <ul> <li>Process is removed from blocked list</li> <li>Typically follows FIFO order for unblocking</li> </ul>"},{"location":"os/ind1/#complete-example-flow","title":"Complete Example Flow","text":"Step S Value Action Result Init 3 P1 enters 2 P() Enters P2 enters 1 P() Enters P3 enters 0 P() Enters P4 tries -1 P() Blocked (in suspended list) P5 tries -2 P() Blocked P1 exits -1 V() S=-1, wake up P4 (now ready) P2 exits 0 V() S=0, wake up P5 (now ready) P3 exits 1 V() No wakeup (S &gt; 0)"},{"location":"os/ind1/#gate-style-questions","title":"GATE-style Questions","text":"<p>Q1: If S = 10, how many processes can enter? - Ans: 10 (each P() reduces S by 1)</p> <p>Q2: If S = 10, and we do: 6 P(), 4 V() - 6 P() \u2192 S = 4 - 4 V() \u2192 S = 8 - Final S = 8</p> <p>Q3: S = 17, ops = 5P, 3V, 1P - 17 - 5 + 3 - 1 = 14 - Final S = 14</p>"},{"location":"os/ind1/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Semaphore avoids race condition and ensures process synchronization</li> <li>Use P() to enter, V() to exit</li> <li>If S &lt; 0, process is blocked</li> <li>FIFO order used to wake blocked processes</li> <li>Binary semaphore \u2192 for mutual exclusion</li> <li>Counting semaphore \u2192 for resource counting</li> </ul>"},{"location":"os/ind1/#binary-semaphore","title":"Binary Semaphore","text":""},{"location":"os/ind1/#what-is-a-binary-semaphore","title":"What is a Binary Semaphore?","text":"<p>A synchronization tool used between cooperative processes, same as Counting Semaphore but values are only 0 or 1.</p> <p>Defined as: \u201cA semaphore that can hold only two values: 0 and 1.\u201d</p>"},{"location":"os/ind1/#binary-vs-counting-semaphore","title":"Binary vs Counting Semaphore","text":"Feature Binary Semaphore Counting Semaphore Values 0 or 1 -\u221e to +\u221e Complexity Simple More general Used for Mutual exclusion Resource counting Preferred in practice Yes Rare"},{"location":"os/ind1/#operations-used","title":"Operations Used","text":"Operation Synonyms Purpose Down() P(), Wait() Entry code \u2192 check &amp; block Up() V(), Signal(), Post() Exit code \u2192 release &amp; wake up"},{"location":"os/ind1/#how-down-works-binary","title":"How Down() Works (Binary)","text":"<pre><code>Down(S):\nif (S == 1)\n    S = 0;              // Successful\nelse\n    block the process;  // S == 0 \u2192 Block it (unsuccessful)\n</code></pre> <ul> <li>S = 1: Enter critical section (mutual exclusion maintained)</li> <li>S = 0: Cannot enter \u2192 process is blocked/suspended</li> </ul>"},{"location":"os/ind1/#how-up-works-binary","title":"How Up() Works (Binary)","text":"<pre><code>Up(S):\nif (suspended list is empty)\n    S = 1;              // Make critical section available\nelse\n    wake up one process from suspended list;\n</code></pre> <ul> <li>If no process is blocked \u2192 simply set S = 1</li> <li>If any process is blocked \u2192 wake one up and move to ready queue</li> </ul>"},{"location":"os/ind1/#example-execution","title":"Example Execution","text":"<p>Scenario:</p> Process Operations P1 Down(S) \u2192 Critical \u2192 Up(S) P2 Down(S) \u2192 Critical \u2192 Up(S) <p>Case 1: S = 1 initially - P2 calls Down(S) \u2192 S becomes 0, enters critical section - P1 calls Down(S) \u2192 blocked (since S is 0) - P2 finishes, calls Up(S) \u2192 wakes P1 (from suspended list) - Result: Mutual exclusion maintained</p> <p>Case 2: S = 0 initially - Both P1 and P2 try Down(S) - Both fail, both get blocked - Result: Deadlock if no one ever gets unblocked</p>"},{"location":"os/ind1/#important-observations","title":"Important Observations","text":"<ul> <li>Binary semaphore ensures one process at a time in critical section.</li> <li>You don\u2019t need to memorize code for exams \u2013 just remember the behavior of:</li> <li>Down() \u2192 blocks if S == 0</li> <li>Up() \u2192 wakes if blocked processes exist</li> <li>In competitive exams (e.g., GATE), initial S value is always given in the question</li> </ul>"},{"location":"os/ind1/#summary-cheat-sheet","title":"Summary Cheat Sheet","text":"State Operation Result S = 1 Down() S \u2192 0, process enters S = 0 Down() Block the process S = 0 + blocked procs Up() Wake up one process S = 0 + no blocked procs Up() S \u2192 1 S = 1 + no blocked procs Up() S stays 1"},{"location":"os/ind1/#mutex","title":"Mutex","text":""},{"location":"os/ind1/#what-is-a-mutex","title":"What is a Mutex?","text":"<p>Mutex stands for Mutual Exclusion. It is a lock-based synchronization tool used to ensure that only one process/thread can access a critical section at a time.</p> <ul> <li>Think of it as: A key to a room: only the one holding the key (lock) can enter the room (critical section).</li> </ul>"},{"location":"os/ind1/#basic-properties","title":"Basic Properties","text":"Property Description Type Lock (not a counting variable) Values Locked (1) or Unlocked (0) Access Only the owner (locking process) can unlock it Scope Works in mutual exclusion, for 1 resource/user Implementation Style OS-level primitive (kernel-based or user-level)"},{"location":"os/ind1/#operations","title":"Operations","text":"Operation Description lock() If unlocked, it locks and enters the critical section. If already locked, the process waits (blocks). unlock() Releases the lock so another process can enter. Only the process that acquired the lock can release it."},{"location":"os/ind1/#mutex-working-example","title":"Mutex Working Example","text":"<p>Scenario: <pre><code>mutex.lock();\ncritical section\nmutex.unlock();\n</code></pre></p> <p>Execution Flow: 1. P1 calls lock() \u2192 succeeds (mutex = locked), enters critical section. 2. P2 calls lock() \u2192 waits (mutex is already locked). 3. P1 finishes \u2192 calls unlock() \u2192 mutex becomes available. 4. P2 now proceeds \u2192 acquires lock \u2192 enters critical section.</p> <ul> <li>Result: Mutual exclusion is maintained!</li> </ul>"},{"location":"os/ind1/#mutex-vs-binary-semaphore","title":"Mutex vs Binary Semaphore","text":"Feature Mutex Binary Semaphore Ownership Has owner No owner (any process can Up) Unlocking Only owner can unlock Any process can perform V() Use-case Thread synchronization Inter-process synchronization Blocking behavior Auto-blocks if locked Needs condition checking Usage simplicity Simple (only lock/unlock) Slightly more generic"},{"location":"os/ind1/#when-to-use-mutex","title":"When to Use Mutex?","text":"<p>Use Mutex when: - You need strict ownership of the lock. - Only one thread/process should access a resource at a time. - Synchronization is required within the same process (multi-threaded).</p>"},{"location":"os/ind1/#summary","title":"Summary","text":"<ul> <li>Mutex ensures mutual exclusion using lock() and unlock().</li> <li>Only the thread that locked the mutex can unlock it.</li> <li>It is simpler and safer than binary semaphore for thread-level locking.</li> <li>Ideal for use in multi-threaded programs (like C++ std::mutex or POSIX threads).</li> </ul>"},{"location":"os/ind2/","title":"Deadlock and Banker's Algorithm","text":"<p>Author: Abhinav P Pradeep </p>"},{"location":"os/ind2/#what-is-deadlock","title":"What is Deadlock?","text":"<p>A deadlock is a situation where two or more processes are waiting for each other to release resources, but none of them proceed because the event they are waiting for never happens.</p>"},{"location":"os/ind2/#real-life-analogies","title":"Real-Life Analogies","text":"Example Explanation Bank Account You: \"Open my account, then I\u2019ll deposit money.\" Bank: \"Deposit first, then we\u2019ll open your account.\" \u2192 Both are waiting on each other \u2192 deadlock Cars at a Narrow Road Car A and Car B face each other on a one-lane road. Neither wants to reverse. \u2192 Both block each other \u2192 deadlock"},{"location":"os/ind2/#technical-deadlock-example","title":"Technical Deadlock Example","text":"<p>Resources: R1 and R2 Processes: P1 and P2 - P1 holds R1 \u2192 requests R2 - P2 holds R2 \u2192 requests R1 Result: Both are waiting for each other to release their resource \u2192 deadlock!</p>"},{"location":"os/ind2/#necessary-conditions-for-deadlock","title":"Necessary Conditions for Deadlock","text":"<p>All 4 conditions must be true for a deadlock to occur:</p> Condition Meaning Example Mutual Exclusion Only one process can hold a resource at a time Printer shared between processes No Pre-emption A resource can\u2019t be forcibly taken; must be released voluntarily P1 keeps R1 until done; P2 must wait Hold and Wait A process holds one resource and waits for another P1 holds R1 and waits for R2 Circular Wait Circular chain of processes waiting on each other P1 \u2192 R2 \u2192 P2 \u2192 R1 \u2192 P1 (forms a loop) <p>Note: All 4 conditions together guarantee a deadlock.</p>"},{"location":"os/ind2/#circular-wait-diagram-example","title":"Circular Wait Diagram Example","text":"<ul> <li>P1 holds R1 \u2192 requests R3  </li> <li>P2 holds R2 \u2192 requests R1  </li> <li>P3 holds R3 \u2192 requests R2 This forms a loop: P1 \u2192 R3 \u2192 P3 \u2192 R2 \u2192 P2 \u2192 R1 \u2192 P1 \u2192 Circular Wait</li> </ul>"},{"location":"os/ind2/#summary","title":"Summary","text":"Feature Description Deadlock When processes block each other permanently due to resource wait Caused by Improper resource allocation + lack of handling strategies 4 Required Conditions Mutual Exclusion, No Pre-emption, Hold &amp; Wait, Circular Wait Detection Resource Allocation Graph or Wait-for Graph Prevention/Avoidance Break at least one of the 4 conditions"},{"location":"os/ind2/#deadlock-handling-techniques-in-os","title":"Deadlock Handling Techniques in OS","text":"<p>There are four major strategies for handling deadlocks:</p>"},{"location":"os/ind2/#deadlock-ignorance-ostrich-method","title":"Deadlock Ignorance (Ostrich Method)","text":"<ul> <li>Idea: Ignore the possibility of deadlock.</li> <li>Real-world use: Common in Windows, Linux, etc.</li> <li>Based on the idea: \"Deadlocks are rare, so let\u2019s not complicate the OS for it.\"</li> <li>Named after: The Ostrich, which hides its head in sand during a storm.</li> </ul> <p>Why used? - Deadlock detection/removal adds overhead. - Systems prioritize performance/speed over rare correctness.</p> <p>Recovery: - When system hangs \u2192 user restarts manually.</p>"},{"location":"os/ind2/#deadlock-prevention","title":"Deadlock Prevention","text":"<ul> <li>Philosophy: \"Prevention is better than cure!\"</li> <li>Approach: Eliminate at least one of the 4 necessary conditions to prevent deadlock.</li> </ul> <p>Four Conditions &amp; How to Break Them:</p> Condition How to Break It Mutual Exclusion Make resources sharable (not always possible, e.g., printer) No Pre-emption Allow OS to take away resources from a process (forcefully) Hold and Wait Allocate all resources at once before execution starts Circular Wait Impose resource ordering, only allow requests in increasing order <p>Resource Numbering for Circular Wait: - Assign numbers: Printer=1, Scanner=2, CPU=3... - A process can only request in increasing order (e.g., 1 \u2192 2 \u2192 3) - Never allowed to request lower-numbered resource \u2192 prevents cycle!</p>"},{"location":"os/ind2/#deadlock-avoidance","title":"Deadlock Avoidance","text":"<ul> <li>Idea: \u201cBefore allocating, check if it\u2019s safe to proceed.\u201d</li> <li>Always check system state is safe before allocating resources.</li> <li>Safe State: There\u2019s at least one execution order where all processes finish without deadlock.</li> </ul> <p>Algorithm Used: - Banker\u2019s Algorithm (by Dijkstra)   - Checks safety before granting a request.   - Works like a loan manager in a bank (grants only if safe).</p>"},{"location":"os/ind2/#deadlock-detection-recovery","title":"Deadlock Detection &amp; Recovery","text":"<ul> <li>Idea: \"Let deadlocks happen, then detect and fix.\"</li> <li>Allows maximum resource utilization but needs post-handling.</li> </ul> <p>Detection: - Use Resource Allocation Graph (RAG) or Wait-for Graph. - Periodically check if there's a cycle \u2192 signals a deadlock.</p> <p>Recovery Methods:</p> Method Description Kill Processes Terminate one-by-one (lowest priority first) until deadlock is resolved Resource Pre-emption Take resource back from a process and give it to others (can cause rollback) <p>Note: Killing or pre-emption affects performance and may cause data inconsistency.</p>"},{"location":"os/ind2/#summary-table","title":"Summary Table","text":"Method Approach Real-world Usage Overhead Notes Deadlock Ignorance Ignore Windows, Linux Low Most used, relies on rarity Deadlock Prevention Eliminate Cause Mostly theoretical Medium Needs strict system control Deadlock Avoidance Predict &amp; Avoid Some systems High Uses Banker\u2019s Algorithm Detection &amp; Recovery Post-solution Used in some systems High Practical but may affect live processes"},{"location":"os/ind2/#bankers-algorithm-deadlock-avoidance","title":"Banker's Algorithm (Deadlock Avoidance)","text":""},{"location":"os/ind2/#why-is-it-called-bankers-algorithm","title":"Why is it called Banker's Algorithm?","text":"<ul> <li>Analogy: Like a banker who gives loans only if it's safe to do so (i.e., won't run out of money later), OS allocates resources only if safe.</li> <li>Proposed by: Dijkstra</li> </ul>"},{"location":"os/ind2/#purpose","title":"Purpose","text":"<ul> <li>Used for Deadlock Avoidance</li> <li>Ensures safe resource allocation</li> <li>Requires advance knowledge of:</li> <li>Total available resources</li> <li>Maximum demand of each process</li> <li>Current allocation</li> <li>Works only with static resource requests</li> </ul>"},{"location":"os/ind2/#input-requirements","title":"Input Requirements","text":"Matrix Meaning Allocation Currently allocated resources to each process Maximum Need Max resources a process may request Available Total \u2013 Allocated resources Need Maximum \u2013 Allocation"},{"location":"os/ind2/#core-concepts","title":"Core Concepts","text":"<ul> <li>Safe State: A system is in a safe state if there exists a safe sequence in which all processes can finish.</li> <li>Unsafe State: Unsafe \u2260 Deadlock, but can lead to deadlock. System cannot guarantee that all processes will complete.</li> </ul>"},{"location":"os/ind2/#how-to-calculate-need-matrix","title":"How to Calculate Need Matrix?","text":"<pre><code>Need[i][j] = Max[i][j] - Allocation[i][j]\n</code></pre>"},{"location":"os/ind2/#bankers-algorithm-steps","title":"Banker's Algorithm Steps","text":"<ol> <li>Calculate Need matrix</li> <li>Initialize Work = Available</li> <li>Finish[i] = false for all processes</li> <li>Find a process such that:</li> <li>Finish[i] == false</li> <li>Need[i] \u2264 Work</li> <li>If found:</li> <li>Allocate resources \u2192 Work = Work + Allocation[i]</li> <li>Mark Finish[i] = true</li> <li>Add process to safe sequence</li> <li>Repeat Step 4</li> <li>If all Finish[i] == true \u2192 Safe State</li> <li>Else \u2192 Deadlock may occur</li> </ol>"},{"location":"os/ind2/#example-flow","title":"Example Flow","text":"<p>Process Table:</p> Process Allocation Max Need Need P1 0 1 0 7 5 3 7 4 3 P2 2 0 0 3 2 2 1 2 2 P3 3 0 2 9 0 2 6 0 0 P4 2 1 1 4 2 2 2 1 1 P5 0 0 2 5 3 3 5 3 1 <p>Available: - Total: 10 5 7 - Allocated: 7 2 5 \u2192 Available = 3 3 2</p> <p>Safe Sequence Output: P2 \u2192 P4 \u2192 P5 \u2192 P1 \u2192 P3</p> <p>Important Conditions to Allocate: A process can be selected only if: <pre><code>Need[i][j] \u2264 Available[j] for all j\n</code></pre></p>"},{"location":"os/ind2/#why-its-not-practical-in-real-os","title":"Why It\u2019s Not Practical in Real OS?","text":"<ul> <li>Needs prior knowledge of max demand \u2192 not feasible</li> <li>Processes have dynamic resource requirements</li> <li>Still useful in theory + competitive exams</li> </ul>"},{"location":"os/ind2/#summary-chart","title":"Summary Chart","text":"Feature Banker's Algorithm Category Deadlock Avoidance Input Needed Allocation, Max, Total Output Safe / Unsafe state Used in Real OS? Not feasible due to dynamic needs Exam Relevance GATE, Interviews Implementation C/C++, Simulations"}]}